
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../resultados/">
      
      
        <link rel="next" href="../python/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.12">
    
    
      
        <title>Solucion C++ - Ecuacion de calor en 2D</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.2afb09e1.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="pink">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#solucion-en-c" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Ecuacion de calor en 2D" class="md-header__button md-logo" aria-label="Ecuacion de calor en 2D" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Ecuacion de calor en 2D
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Solucion C++
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Ecuacion de calor en 2D" class="md-nav__button md-logo" aria-label="Ecuacion de calor en 2D" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Ecuacion de calor en 2D
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Introducción
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../metodos/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Metodología
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../resultados/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Resultados
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    Solucion C++
    
  </span>
  

      </a>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../python/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Solucion Python
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../bibliografia/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Bibligrafía
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="solucion-en-c">Solución en C++</h1>
<p>El presente código en C++ tiene como objetivo resolver la ecuación de calor en dos dimensiones. Para resolverla de forma eficiente, el código implementa el método Crank–Nicolson con Alternating Direction Implicit (ADI). Este método permite dividir cada paso temporal en dos subpasos alternados en dirección horizontal y vertical, facilitando la resolución de matrices tridiagonales mediante el eficiente método de Thomas.</p>
<p>Además, se integran técnicas de paralelismo de memoria compartida usando OpenMP, lo que permite reducir significativamente los tiempos de cálculo. El código está diseñado para permitir la elección entre distintas condiciones iniciales</p>
<hr />
<p>La siguiente función crea una matriz representada como un vector de 1D:\
Se utilizaron las siguientes bibliotecas:</p>
<ul>
<li><code>&lt;iostream&gt;</code>: Para poder utilizar inputs y outputs con std.</li>
<li><code>&lt;cmath&gt;</code>: Para poder agregar funciones matemáticas</li>
<li><code>&lt;vector&gt;</code>: Para poder usar std::vector</li>
<li><code>&lt;omp.h&gt;</code>: Para paralelizar con OpenMP</li>
</ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;omp.h&gt;
</code></pre>
<p><strong>Función que crea una matriz llena de ceros, y la almacena en 1 vector de 1D</strong>\
<code>n</code> Número de filas.\
<code>m</code> Número de columnas.\
<code>return std::vector&lt;double&gt;</code> Se retorna un vector <code>nxm</code> que contiene los arreglos de ceros</p>
<pre><code class="language-cpp">std::vector&lt;double&gt; crearMatrizCeros(int n, int m) {
    return std::vector&lt;double&gt;(n * m, 0.0);
}
</code></pre>
<p><strong>Función que imprime la matriz creada anteriormente</strong>\
Se imprime en la consola la matriz nxn contenida en un vector de 1D. Para esto se utilzan 3 cifras decimales por cada entrada de la matriz.\
<code>matriz</code> Vector que contiene la matriz creada previamente de forma lineal.\
<code>n</code> Número de filas de la matriz.</p>
<pre><code class="language-cpp">void imprimirMatriz(const std::vector&lt;double&gt;&amp; matriz, int n) {
    for (int i = 0; i &lt; n; ++i) {
        for (int j = 0; j &lt; n; ++j) {
            printf(&quot;%.3f &quot;, matriz[i * n + j]);
        }
        printf(&quot;\n&quot;);
    }
    printf(&quot;\n&quot;);
}
</code></pre>
<p><strong>Función que multiplica la matriz anteior por un vector.</strong>\
Se hace una multiplicación entre la matriz guardada en el vector 1D y un vector de las mismas dimensiones. 
El resultado obtenido de la multiplicación sobreescribe el vector original utilizado.\
<code>matriz</code> Vector que contiene la matriz creada previamente de forma lineal.\
<code>vec</code> Vector por el cual se multiplica la matriz, y en el cual se guardan los resultados de la multiplicación.\
<code>n</code> Número de filas de la matriz.\</p>
<pre><code class="language-cpp">void multiplicarMatrizVector(const std::vector&lt;double&gt;&amp; matriz, std::vector&lt;double&gt;&amp; vec, int n) {
    std::vector&lt;double&gt; temp(n, 0.0);
    for (int i = 0; i &lt; n; ++i)
        for (int j = 0; j &lt; n; ++j)
            temp[i] += matriz[i * n + j] * vec[j];
    vec = temp; 
}
</code></pre>
<p><strong>Función que resuelve el sistema tridiagonal usando el método de Thomas</strong>\
Se resuelve el sistema de ecuaciones lineales obtenido, el cual incluye una matriz tridiagonal, utilizando el método de Thomas. La solución se almacena en el vector u, sobrescribiendo así su contenido.\
<code>T</code> Matriz tridiagonal resuelta por medio del método de Thomas, y almacenada de forma 1D.\
<code>u</code> Vector con los términos independientes del sistema tridiagonal.\
<code>n</code> Dimensión de la matriz.\
El resultado final se guarda en el vector <code>u</code>.</p>
<pre><code class="language-cpp">void resolverTridiagonal(const std::vector&lt;double&gt;&amp; T, std::vector&lt;double&gt;&amp; u, int n) {
    std::vector&lt;double&gt; a(n, 0.0), b(n, 0.0), c(n, 0.0), x(n, 0.0);
    for (int i = 0; i &lt; n; i++) b[i] = T[i * n + i];
    for (int i = 0; i &lt; n-1; i++) {
        a[i+1] = T[(i+1) * n + i];
        c[i] = T[i * n + (i + 1)];
    }
    c[0] /= b[0];
    x[0] = u[0] / b[0];
    for (int i = 1; i &lt; n; i++) {
        double m = b[i] - a[i] * c[i-1];
        c[i] /= m;
        x[i] = (u[i] - a[i] * x[i-1]) / m;
    }
    for (int i = n - 2; i &gt;= 0; i--)
        x[i] -= c[i] * x[i + 1];
    u = x;
}
</code></pre>
<p><strong>Función que crea una matriz tridiagonal implicita</strong>\
 Se crea una matriz tridiagonal implícita con valores 1+2r en la diagonal principal y -r en las otras dos diagonales.\
 <code>n</code> Dimensión de la matriz.\
 <code>r</code> Valor de la variable discretizada que relaciona la parte espacial y temporal de la ecuación diferencial.\
<code>return Laplaciano</code> Se retorna un Laplaciano tridiagonal implícito nxn.</p>
<pre><code class="language-cpp">std::vector&lt;double&gt; crearLaplacianoImplicito(int n, double r) {
    std::vector&lt;double&gt; Laplaciano(n * n, 0.0);
    for (int i = 0; i &lt; n; ++i) {
        if (i == 0 || i == n - 1) {
            Laplaciano[i * n + i] = 1.0;
        } else {
            Laplaciano[i * n + (i - 1)] = -r;
            Laplaciano[i * n + i] = 1 + 2 * r;
            Laplaciano[i * n + (i + 1)] = -r;
        }
    }
    return Laplaciano;
}
</code></pre>
<p><strong>Función que crea una matriz tridiagonal explicita</strong>\
Se crea una matriz tridiagonal explícita con valores 1-2r en la diagonal principal y r en las otras dos diagonales.\
<code>n</code> Dimensión de la matriz.\
<code>r</code> Valor de la variable discretizada que relaciona la parte espacial y temporal de la ecuación diferencial.\
<code>return Laplaciano</code> Se retorna un Laplaciano tridiagonal explícito nxn.</p>
<pre><code class="language-cpp">std::vector&lt;double&gt; crearLaplacianoExplicito(int n, double r) {
    std::vector&lt;double&gt; Laplaciano(n * n, 0.0);
    for (int i = 0; i &lt; n; ++i) {
        if (i == 0 || i == n - 1) {
            Laplaciano[i * n + i] = 1;
        } else {
            Laplaciano[i * n + (i - 1)] = r;
            Laplaciano[i * n + i] = 1 - 2 * r;
            Laplaciano[i * n + (i + 1)] = r;
        }
    }
    return  Laplaciano;
}
</code></pre>
<p><strong>Función que calcula el método de Crank Nicholson con Alternating Direction Implicit (ADI)</strong>\
La función resuelve la ecuación de calor en 2D dividiendo la parte temporal de problema en 2 subpasos:
Una parte para la dirección y y otra para la dirección x. Esto facilita poder utilizar el método de Crank
Nicholson al reducirlo con matrices tridiagonales. Además en cada subpaso se calcula la multiplicación de de matrices y la resolución de la matriz tridiagonal por medio del método de Thomas.\
Para la parte de la paralelización se utilizó estratégicamente en los bucles for que involucran filas y columnas  de la malla, ya que al agregarlo en dichos <code>for</code>, la velocidad del código mejora considerablemente.\
<code>matriz</code> Matriz almacenada como un vector 1D.\
<code>n</code> Número de puntos a utilizar\
<code>r</code> Valor de la variable discretizada que relaciona la parte espacial y temporal de la ecuación diferencial.\
<code>pasos</code> Número de pasos a utilizar.\
<code>bordeIzq</code> Valor de frontera en el borde izquierdo.\
<code>bordeDer</code> Valor de frontera en el borde derecho.\
<code>bordeInf</code> Valor de frontera del borde inferior.\
<code>bordeSup</code> Valor de frontera del borde superior.</p>
<pre><code class="language-cpp">void CN_2D_ADI_Advance(std::vector&lt;double&gt;&amp; matriz, int n, double r, int pasos,
                       double bordeIzq, double bordeDer, double bordeInf, double bordeSup) {

    r = r / 2.0;
    std::vector&lt;double&gt; S = crearLaplacianoExplicito(n, r);
    std::vector&lt;double&gt; T = crearLaplacianoImplicito(n, r);
    std::vector&lt;double&gt; temp(n * n, 0.0);
    std::vector&lt;double&gt; fila(n);
    std::vector&lt;double&gt; columna(n);

    for (int t = 0; t &lt; pasos; ++t) {

        # pragma omp parallel for
        for (int i = 0; i &lt; n; ++i) {
          std::vector&lt;double&gt; fila(n);
          for (int j = 0; j &lt; n; ++j)
            fila[j] = matriz[i * n +j];
          multiplicarMatrizVector(S, fila, n);
          for (int j = 0; j &lt; n; ++j)
            matriz[i * n +j] = fila[j];
        }


        # pragma omp parallel for
        for (int j = 0; j &lt; n; ++j) {
            std::vector&lt;double&gt; columna(n);
            for (int i = 0; i &lt; n; ++i)
                columna[i] = matriz[i * n + j];
            resolverTridiagonal(T, columna, n);
            for (int i = 0; i &lt; n; ++i)
                matriz[i * n + j] = columna[i];
        }



        # pragma omp parallel for
        for (int j = 0; j &lt; n; ++j) {
          std::vector&lt;double&gt; columna(n);
          for (int i = 0; i &lt; n; ++i)
            columna[i] = matriz[i * n +j];
          multiplicarMatrizVector(S, columna, n);
          for (int i = 0; i &lt; n; ++i)
            matriz[i * n + j] = columna[i];
        }



        # pragma omp parallel for
        for (int i = 0; i &lt; n; ++i) {
            std::vector&lt;double&gt; fila(n);
            for (int j = 0; j &lt; n; ++j)
                fila[j] = matriz[i * n +j];
            resolverTridiagonal(T, fila, n);
            for (int j = 0; j &lt; n; ++j)
                matriz[i * n + j] = fila[j];
        }
    }
}
</code></pre>
<p><strong>Clase</strong> 
<code>solucion_ecuacion_calor</code> Consiste en los procesos necesarios para resolver el problema.
En esta se configuran las condiciones iniciales y de frontera, además de que se crean las funciones con las cuáles se calcula la solución del 
problema.</p>
<p><strong>Atributos</strong>
- <code>n, dt, t, alpha2, ds, r, pasos</code>: parámetros numéricos.
- <code>opcion</code>: condición inicial seleccionada.
- <code>condicion_frontera</code>: tipo de borde (1: Dirichlet, 2: Neumann, 3: Robin).
- <code>matriz</code>: contiene los valores de temperatura.</p>
<p><strong>Funciones públicas</strong></p>
<pre><code class="language-cpp">solucion_ecuacion_calor(int n, double dt, double t, double alpha2 = 1.0);
void opcion_escogida(int opcion_variable);
void condicion_front_escog(int condicion);
void aplicar_condicion_inicial();
void evaluar_condicion_frontera();
void resolver();
void imprimir();
</code></pre>
<p><strong>Funciones privadas</strong></p>
<pre><code class="language-cpp">double evaluar_condicion_ini(double x, double y);
</code></pre>
<p>Evaluá la condición inicial dependiendo de la opción escogida.</p>
<p><strong>Función main</strong>\
Inicializa todo el código para resolver la ecuación de calor en 2-D. Para esto el usuario primero debe de escoger una de las tres condiciones iniciales y una de las tres condiciones de frontera. El programa evalúa dicha condición incial usando el método de Crank Nicholson y la reducción de la matriz tridiagonal con el método de Thomas, y luego imprime el resultado obtenido.\
<code>return 0</code> si el programa se ejecuta sin ningún problema, y 1 si la opción elegida no era válida.</p>
<pre><code class="language-cpp">int main() {
    int ns = 50;
    double dt = 0.0005, t = 0.1;

    int opcion_cond_ini;
    std::cout &lt;&lt; &quot;Escoja una de las siguientes condiciones iniciales al ingresar el número correspondiente: \n&quot;;
    std::cout &lt;&lt; &quot; 1. Pulso Gaussiano centrado \n2. Paraboloide centrado \n3. Onda senoidal suave \n&quot;;
    std::cin &gt;&gt; opcion_cond_ini;

    int condicion_frontera;
    std::cout &lt;&lt; &quot;Escoja una de las siguientes condiciones de frontera al ingresar el número correspondiente: \n&quot;;
    std::cout &lt;&lt; &quot; 1. Dirichlet \n2. Neuman \n3. Robin \n&quot;;
    std::cin &gt;&gt; condicion_frontera;

    if (opcion_cond_ini &lt; 1 || opcion_cond_ini &gt; 3) {
        std::cerr &lt;&lt; &quot;La opción elegida no es válida. \n&quot;;
        return 1;
    }

    // Se crea el constructor y se usa para llamar las funciones.
    solucion_ecuacion_calor constructor(ns, dt, t);
    constructor.opcion_escogida(opcion_cond_ini);
    constructor.condicion_front_escog(condicion_frontera);
    constructor.aplicar_condicion_inicial();
    constructor.resolver();
    constructor.imprimir();

    return 0;
}
</code></pre>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.f8cc74c7.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.c8b220af.min.js"></script>
      
        <script src="../javascripts/mathjax.js"></script>
      
        <script src="https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>