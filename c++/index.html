
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../resultados/">
      
      
        <link rel="next" href="../python/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.12">
    
    
      
        <title>Solucion C++ - Ecuacion de calor en 2D</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.2afb09e1.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="pink">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#solucion-en-c" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Ecuacion de calor en 2D" class="md-header__button md-logo" aria-label="Ecuacion de calor en 2D" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Ecuacion de calor en 2D
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Solucion C++
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Ecuacion de calor en 2D" class="md-nav__button md-logo" aria-label="Ecuacion de calor en 2D" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Ecuacion de calor en 2D
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Introduccion
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../metodos/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Metodologi
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../resultados/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Resultados
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    Solucion C++
    
  </span>
  

      </a>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../python/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Solucion Python
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="solucion-en-c">Solución en C++</h1>
<p>El presente código en C++ tiene como objetivo resolver la ecuación de calor en dos dimensiones. Para resolverla de forma eficiente, el código implementa el método Crank–Nicolson con Alternating Direction Implicit (ADI). Este método permite dividir cada paso temporal en dos subpasos alternados en dirección horizontal y vertical, facilitando la resolución de matrices tridiagonales mediante el eficiente método de Thomas.</p>
<p>Además, se integran técnicas de paralelismo de memoria compartida usando OpenMP, lo que permite reducir significativamente los tiempos de cálculo. El código está diseñado para permitir la elección entre distintas condiciones iniciales</p>
<hr />
<p>La siguiente función crea una matriz representada como un vector de 1D:\
Se utilizaron las siguientes bibliotecas:</p>
<ul>
<li><code>&lt;iostream&gt;</code>: Para poder utilizar inputs y outputs con std.</li>
<li><code>&lt;cmath&gt;</code>: Para poder agregar funciones matemáticas</li>
<li><code>&lt;vector&gt;</code>: Para poder usar std::vector</li>
<li><code>&lt;omp.h&gt;</code>: Para paralelizar con OpenMP</li>
</ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;omp.h&gt;
</code></pre>
<p><strong>Función que crea una matriz llena de ceros, y la almacena en 1 vector de 1D</strong>\
<code>n</code> Número de filas.\
<code>m</code> Número de columnas.\
<code>return std::vector&lt;double&gt;</code> Se retorna un vector <code>nxm</code> que contiene los arreglos de ceros</p>
<pre><code class="language-cpp">std::vector&lt;double&gt; crearMatrizCeros(int n, int m) {
    return std::vector&lt;double&gt;(n * m, 0.0);
}
</code></pre>
<p><strong>Función que imprime la matriz creada anteriormente</strong>\
Se imprime en la consola la matriz nxn contenida en un vector de 1D. Para esto se utilzan 3 cifras decimales por cada entrada de la matriz.\
<code>matriz</code> Vector que contiene la matriz creada previamente de forma lineal.\
<code>n</code> Número de filas de la matriz.</p>
<pre><code class="language-cpp">void imprimirMatriz(const std::vector&lt;double&gt;&amp; matriz, int n) {
    for (int i = 0; i &lt; n; ++i) {
        for (int j = 0; j &lt; n; ++j) {
            printf(&quot;%.3f &quot;, matriz[i * n + j]);
        }
        printf(&quot;\n&quot;);
    }
    printf(&quot;\n&quot;);
}
</code></pre>
<p><strong>Función que multiplica la matriz anteior por un vector.</strong>\
Se hace una multiplicación entre la matriz guardada en el vector 1D y un vector de las mismas dimensiones. 
El resultado obtenido de la multiplicación sobreescribe el vector original utilizado.\
<code>matriz</code> Vector que contiene la matriz creada previamente de forma lineal.\
<code>vec</code> Vector por el cual se multiplica la matriz, y en el cual se guardan los resultados de la multiplicación.\
<code>n</code> Número de filas de la matriz.\</p>
<pre><code class="language-cpp">void multiplicarMatrizVector(const std::vector&lt;double&gt;&amp; matriz, std::vector&lt;double&gt;&amp; vec, int n) {
    std::vector&lt;double&gt; temp(n, 0.0);
    for (int i = 0; i &lt; n; ++i)
        for (int j = 0; j &lt; n; ++j)
            temp[i] += matriz[i * n + j] * vec[j];
    vec = temp; 
}
</code></pre>
<p><strong>Función que resuelve el sistema tridiagonal usando el método de Thomas</strong>\
Se resuelve el sistema de ecuaciones lineales obtenido, el cual incluye una matriz tridiagonal, utilizando el método de Thomas. La solución se almacena en el vector u, sobrescribiendo así su contenido.\
<code>T</code> Matriz tridiagonal resuelta por medio del método de Thomas, y almacenada de forma 1D.\
<code>u</code> Vector con los términos independientes del sistema tridiagonal.\
<code>n</code> Dimensión de la matriz.\
El resultado final se guarda en el vector <code>u</code>.</p>
<pre><code class="language-cpp">void resolverTridiagonal(const std::vector&lt;double&gt;&amp; T, std::vector&lt;double&gt;&amp; u, int n) {
    std::vector&lt;double&gt; a(n, 0.0), b(n, 0.0), c(n, 0.0), x(n, 0.0);
    for (int i = 0; i &lt; n; i++) b[i] = T[i * n + i];
    for (int i = 0; i &lt; n-1; i++) {
        a[i+1] = T[(i+1) * n + i];
        c[i] = T[i * n + (i + 1)];
    }
    c[0] /= b[0];
    x[0] = u[0] / b[0];
    for (int i = 1; i &lt; n; i++) {
        double m = b[i] - a[i] * c[i-1];
        c[i] /= m;
        x[i] = (u[i] - a[i] * x[i-1]) / m;
    }
    for (int i = n - 2; i &gt;= 0; i--)
        x[i] -= c[i] * x[i + 1];
    u = x;
}
</code></pre>
<p><strong>Función que crea una matriz tridiagonal implicita</strong>\
 Se crea una matriz tridiagonal implícita con valores 1+2r en la diagonal principal y -r en las otras dos diagonales.\
 <code>n</code> Dimensión de la matriz.\
 <code>r</code> Valor de la variable discretizada que relaciona la parte espacial y temporal de la ecuación diferencial.\
<code>return Laplaciano</code> Se retorna un Laplaciano tridiagonal implícito nxn.</p>
<pre><code class="language-cpp">std::vector&lt;double&gt; crearLaplacianoImplicito(int n, double r) {
    std::vector&lt;double&gt; Laplaciano(n * n, 0.0);
    for (int i = 0; i &lt; n; ++i) {
        if (i == 0 || i == n - 1) {
            Laplaciano[i * n + i] = 1.0;
        } else {
            Laplaciano[i * n + (i - 1)] = -r;
            Laplaciano[i * n + i] = 1 + 2 * r;
            Laplaciano[i * n + (i + 1)] = -r;
        }
    }
    return Laplaciano;
}
</code></pre>
<p><strong>Función que crea una matriz tridiagonal explicita</strong>\
Se crea una matriz tridiagonal explícita con valores 1-2r en la diagonal principal y r en las otras dos diagonales.\
<code>n</code> Dimensión de la matriz.\
<code>r</code> Valor de la variable discretizada que relaciona la parte espacial y temporal de la ecuación diferencial.\
<code>return Laplaciano</code> Se retorna un Laplaciano tridiagonal explícito nxn.</p>
<pre><code class="language-cpp">std::vector&lt;double&gt; crearLaplacianoExplicito(int n, double r) {
    std::vector&lt;double&gt; Laplaciano(n * n, 0.0);
    for (int i = 0; i &lt; n; ++i) {
        if (i == 0 || i == n - 1) {
            Laplaciano[i * n + i] = 1;
        } else {
            Laplaciano[i * n + (i - 1)] = r;
            Laplaciano[i * n + i] = 1 - 2 * r;
            Laplaciano[i * n + (i + 1)] = r;
        }
    }
    return  Laplaciano;
}
</code></pre>
<p><strong>Función que calcula el método de Crank Nicholson con Alternating Direction Implicit (ADI)</strong>\
La función resuelve la ecuación de calor en 2D dividiendo la parte temporal de problema en 2 subpasos:
Una parte para la dirección y y otra para la dirección x. Esto facilita poder utilizar el método de Crank
Nicholson al reducirlo con matrices tridiagonales. Además en cada subpaso se calcula la multiplicación de de matrices y la resolución de la matriz tridiagonal por medio del método de Thomas.\
Para la parte de la paralelización se utilizó estratégicamente en los bucles for que involucran filas y columnas  de la malla, ya que al agregarlo en dichos <code>for</code>, la velocidad del código mejora considerablemente. Por último, también se calcularon las condiciones de frontera de Dirichlet en los bordes de la malla.\
<code>matriz</code> Matriz almacenada como un vector 1D.\
<code>n</code> Número de puntos a utilizar\
<code>r</code> Valor de la variable discretizada que relaciona la parte espacial y temporal de la ecuación diferencial.\
<code>pasos</code> Número de pasos a utilizar.\
<code>bordeIzq</code> Valor de frontera en el borde izquierdo.\
<code>bordeDer</code> Valor de frontera en el borde derecho.\
<code>bordeInf</code> Valor de frontera del borde inferior.\
<code>bordeSup</code> Valor de frontera del borde superior.</p>
<pre><code class="language-cpp">void CN_2D_ADI_Advance(std::vector&lt;double&gt;&amp; matriz, int n, double r, int pasos,
                       double bordeIzq, double bordeDer, double bordeInf, double bordeSup) {

    r = r / 2.0;
    std::vector&lt;double&gt; S = crearLaplacianoExplicito(n, r);
    std::vector&lt;double&gt; T = crearLaplacianoImplicito(n, r);
    std::vector&lt;double&gt; temp(n * n, 0.0);
    std::vector&lt;double&gt; fila(n);
    std::vector&lt;double&gt; columna(n);

    for (int t = 0; t &lt; pasos; ++t) {

        # pragma omp parallel for
        for (int i = 0; i &lt; n; ++i) {
          std::vector&lt;double&gt; fila(n);
          for (int j = 0; j &lt; n; ++j)
            fila[j] = matriz[i * n +j];
          multiplicarMatrizVector(S, fila, n);
          for (int j = 0; j &lt; n; ++j)
            matriz[i * n +j] = fila[j];
        }


        # pragma omp parallel for
        for (int j = 0; j &lt; n; ++j) {
            std::vector&lt;double&gt; columna(n);
            for (int i = 0; i &lt; n; ++i)
                columna[i] = matriz[i * n + j];
            resolverTridiagonal(T, columna, n);
            for (int i = 0; i &lt; n; ++i)
                matriz[i * n + j] = columna[i];
        }



        # pragma omp parallel for
        for (int j = 0; j &lt; n; ++j) {
          std::vector&lt;double&gt; columna(n);
          for (int i = 0; i &lt; n; ++i)
            columna[i] = matriz[i * n +j];
          multiplicarMatrizVector(S, columna, n);
          for (int i = 0; i &lt; n; ++i)
            matriz[i * n + j] = columna[i];
        }



        # pragma omp parallel for
        for (int i = 0; i &lt; n; ++i) {
            std::vector&lt;double&gt; fila(n);
            for (int j = 0; j &lt; n; ++j)
                fila[j] = matriz[i * n +j];
            resolverTridiagonal(T, fila, n);
            for (int j = 0; j &lt; n; ++j)
                matriz[i * n + j] = fila[j];
        }


        # pragma omp parallel for
        for (int i = 0; i &lt; n; i++) {
            matriz[i * n + 0] = bordeInf;
            matriz[i * n + n -1] = bordeSup;
            matriz[0 * n + i] = bordeIzq;
            matriz[(n - 1) * n + i]= bordeDer;
        }
}
                       }

</code></pre>
<p><strong>Función para la condición inicial del paraboloide centrado</strong>\
<code>x</code> Coordenada x normalizada (entre 0 y 1).\
<code>y</code> Coordenada y normalizada (entre 0 y 1).\
<code>return</code> Valor de la distribución de la temperatura en el paraboloide.</p>
<pre><code class="language-cpp">double paraboloide(double x, double y) {
    double cx = x - 0.5, cy = y - 0.5;
    return 1000 * (cx*cx + cy*cy);
}
</code></pre>
<p>Función para la condición inicial del toroide.
x Coordenada x normalizada (entre 0 y 1).
y Coordenada y normalizada (entre 0 y 1).
return Valor de la distribución de la temperatura en el toroide.</p>
<pre><code class="language-cpp">double toroide(double x, double y){
    double dx = x - 0.5;
    double dy = y - 0.5;
    double radio = sqrt((dx * dx) + (dy * dy));
    double dist_rad = radio - 0.25;
    return 1000 * exp(-(dist_rad * dist_rad) / (0.0035));
}
</code></pre>
<p>Función para la condición inicial de la barra centrada.
x Coordenada x normalizada (entre 0 y 1).
y Coordenada y normalizada (entre 0 y 1).
return Valor de la distribución de la temperatura en la barra centrada.</p>
<pre><code class="language-cpp">double barra_horizontal(double x, double y){
    double orientacion = abs(y - 0.5);
    return (orientacion &lt; 0.1) ? 1000 : 0;
}
</code></pre>
<p><strong>Función para la condición inicial de la campana gaussiana centrada</strong>\
<code>x</code> Coordenada x normalizada (entre 0 y 1).\
<code>y</code> Coordenada y normalizada (entre 0 y 1).\
<code>return</code> Valor de la distribución de la temperatura en la campana gaussiana centrada.</p>
<pre><code class="language-cpp">double campana_gaussiana_centr(double x, double y){
    double dx = x - 0.5;
    double dy = y - 0.5;
    double radio = sqrt((dx * dx) + (dy * dy));
    return 1000 * exp(-radio / 0.01);
}
</code></pre>
<p>Función para la condición inicial de la campana gaussiana estrecha.
x Coordenada x normalizada (entre 0 y 1).
y Coordenada y normalizada (entre 0 y 1).
return Valor de la distribución de la temperatura en la campana gaussiana estrecha.</p>
<pre><code class="language-cpp">double campana_gaussiana_estr(double x, double y){
    double dx = x - 0.5;
    double dy = y - 0.5;
    double radio = sqrt((dx * dx) + (dy * dy));
    return 1000 * exp(-radio / 0.000001);
}
</code></pre>
<p><strong>Función para la condición inicial de la onda senosoidal</strong>\
<code>x</code> Coordenada x normalizada (entre 0 y 1).\
<code>y</code> Coordenada y normalizada (entre 0 y 1).\
<code>return</code> Valor de la distribución de la temperatura en la onda senosoidal.</p>
<pre><code class="language-cpp">double onda_senosoidal(double x, double y){
    const double Pi = 3.1415926535;
    return 1000 * (sin(2 * Pi * x) * sin(2 * Pi * y));
}
</code></pre>
<p><strong>Función main</strong>\
Inicializa todo el código para resolver la ecuación de calor en 2-D. Para esto el usuario primero debe de escoger una de las seis condiciones iniciales. El programa evalúa dicha condición incial usando el método de Crank Nicholson y la reducción de la matriz tridiagonal con el método de Thomas, y luego imprime el resultado obtenido.\
<code>return 0</code> si el programa se ejecuta sin ningún problema, y 1 si la opción elegida no era válida.</p>
<pre><code class="language-cpp">int main() {
    int ns = 26;
    double dt = .00001, t = .1;
    double alpha2 = 1, x0 = 0, xL = 0, y0 = 0, yL = 0;
    double ds = 1.0 / (ns - 1);
    double r = alpha2 * dt / (ds * ds);
    int pasos = (int)(t / dt);


int opcion_cond_ini;
std::cout &lt;&lt; &quot;Escoja una de las siguientes condiciones iniciales al ingresar el número correspondiente: \n&quot;;
std::cout &lt;&lt; &quot; 1. Paraboloide centrado \n2. Toroide \n3. Barra horizontal centrada&quot;;
std::cout &lt;&lt; &quot; \n4.Campana gaussiana centrada \n5. Campana gaussiana estrecha \n6. Onda senosoidal\n&quot;;

std::cin &gt;&gt; opcion_cond_ini;


if (opcion_cond_ini &lt; 1 || opcion_cond_ini &gt; 6){
    std::cerr &lt;&lt; &quot;La opción elegida no es válida. \n&quot;;
    return 1;
}


    std::vector&lt;double&gt; matriz = crearMatrizCeros(ns, ns);
    for (int i = 0; i &lt; ns; i++) {
        for (int j = 0; j &lt; ns; j++) {
            double x = i * ds;
            double y = j * ds;
            if (opcion_cond_ini == 1) matriz[i * ns + j] = paraboloide(x, y);
            else if (opcion_cond_ini == 2) matriz[i * ns + j] = toroide(x, y);
            else if (opcion_cond_ini == 3) matriz[i * ns + j] = barra_horizontal(x, y);
            else if (opcion_cond_ini == 4) matriz[i * ns + j] = campana_gaussiana_centr(x, y);
            else if (opcion_cond_ini == 5) matriz[i * ns + j] = campana_gaussiana_estr(x, y);
            else if (opcion_cond_ini == 6) matriz[i * ns + j] = onda_senosoidal(x, y);
        }
    }


    for (int i = 0;i &lt; ns; i++){
        matriz[i * ns + 0] = y0;
        matriz[i * ns + (ns -1)] = yL;
        matriz[0 * ns + i] = x0;
        matriz[(ns - 1) * ns + i] = xL;

    }

    CN_2D_ADI_Advance(matriz, ns, r, pasos, x0, xL, y0, yL);
    imprimirMatriz(matriz, ns);

    return 0;
}
</code></pre>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.f8cc74c7.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.c8b220af.min.js"></script>
      
        <script src="../javascripts/mathjax.js"></script>
      
        <script src="https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>