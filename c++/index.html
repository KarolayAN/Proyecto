
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../condiciones/">
      
      
        <link rel="next" href="../python/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.12">
    
    
      
        <title>Solucion C++ - Ecuacion de calor en 2D</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.2afb09e1.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="pink">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#solucion-en-c" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Ecuacion de calor en 2D" class="md-header__button md-logo" aria-label="Ecuacion de calor en 2D" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Ecuacion de calor en 2D
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Solucion C++
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Ecuacion de calor en 2D" class="md-nav__button md-logo" aria-label="Ecuacion de calor en 2D" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Ecuacion de calor en 2D
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Introducción
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../metodos/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Metodología
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../condiciones/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Condiciones
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    Solucion C++
    
  </span>
  

      </a>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../python/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Solucion Python
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../resultados/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Resultados
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../bibliografia/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Bibligrafía
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="solucion-en-c">Solución en C++</h1>
<p>El presente código en C++ tiene como objetivo resolver la ecuación de calor en dos dimensiones. Para resolverla de forma eficiente, el código implementa el método Crank–Nicolson con Alternating Direction Implicit (ADI). Este método permite dividir cada paso temporal en dos subpasos alternados en dirección horizontal y vertical, facilitando la resolución de matrices tridiagonales mediante el eficiente método de Thomas.</p>
<p>Además, se integran técnicas de paralelismo de memoria compartida usando OpenMP, lo que permite reducir significativamente los tiempos de cálculo. El código está diseñado para permitir la elección entre distintas condiciones iniciales</p>
<hr />
<p>La siguiente función crea una matriz representada como un vector de 1D:</p>
<p>Se utilizaron las siguientes bibliotecas:</p>
<ul>
<li>
<p><code>&lt;iostream&gt;</code>: Para poder utilizar inputs y outputs con std.</p>
</li>
<li>
<p><code>&lt;cmath&gt;</code>: Para poder agregar funciones matemáticas</p>
</li>
<li>
<p><code>&lt;vector&gt;</code>: Para poder usar std::vector</p>
</li>
<li>
<p><code>&lt;omp.h&gt;</code>: Para paralelizar con OpenMP</p>
</li>
</ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;omp.h&gt;
</code></pre>
<p><strong>Función que crea una matriz llena de ceros, y la almacena en 1 vector de 1D</strong></p>
<p><code>crearMatrizCeros(int n, int m)</code> genera una matriz de ceros con <code>n</code> filas y <code>m</code> columnas, representada como un vector unidimensional (<code>std::vector&lt;double&gt;</code>) de tamaño <code>n × m</code>. </p>
<p><code>[i * n + j]</code> convierte coordenadas bidimensionales (i, j) fila y columna de una matriz 2D, en una posición dentro de un vector de una sola dimensión (1D).</p>
<p><code>[i * n + j]</code> se utiliza para convertir coordenadas bidimensionales <code>(i, j)</code> donde <code>i</code> representa la fila y <code>j</code> la columna en una única posición dentro de un vector unidimensional que simula una matriz 2D. En este contexto, <code>n</code> es el número total de columnas. Esto permite representar matrices como arreglos lineales de una sola dimensión, lo cual es más eficiente en términos de memoria y procesamiento.</p>
<p>Todos los valores se inicializan en cero (<code>0.0</code>), lo que es importante para establecer una temperatura base uniforme</p>
<pre><code class="language-cpp">std::vector&lt;double&gt; crearMatrizCeros(int n, int m) {
    return std::vector&lt;double&gt;(n * m, 0.0);
}
</code></pre>
<p><strong>Función que imprime la matriz creada anteriormente</strong></p>
<p>Se imprime en la consola la matriz nxn contenida en un vector de 1D. Para esto se utilzan 3 cifras decimales por cada entrada de la matriz.</p>
<p><code>matriz</code> Vector que contiene la matriz creada previamente de forma lineal.</p>
<p><code>n</code> Número de filas de la matriz.</p>
<pre><code class="language-cpp">void imprimirMatriz(const std::vector&lt;double&gt;&amp; matriz, int n) {
    for (int i = 0; i &lt; n; ++i) {
        for (int j = 0; j &lt; n; ++j) {
            printf(&quot;%.3f &quot;, matriz[i * n + j]);
        }
        printf(&quot;\n&quot;);
    }
    printf(&quot;\n&quot;);
}
</code></pre>
<p><strong>Función que multiplica la matriz anteior por un vector.</strong></p>
<p>Se hace una multiplicación entre la matriz guardada en el vector 1D y un vector de las mismas dimensiones. 
El resultado obtenido de la multiplicación sobreescribe el vector original utilizado.</p>
<p><code>matriz</code> Vector que contiene la matriz creada previamente de forma lineal.</p>
<p><code>vec</code> Vector por el cual se multiplica la matriz, y en el cual se guardan los resultados de la multiplicación.</p>
<p><code>n</code> Número de filas de la matriz.</p>
<pre><code class="language-cpp">void multiplicarMatrizVector(const std::vector&lt;double&gt;&amp; matriz, std::vector&lt;double&gt;&amp; vec, int n) {
    std::vector&lt;double&gt; temp(n, 0.0);
    for (int i = 0; i &lt; n; ++i)
        for (int j = 0; j &lt; n; ++j)
            temp[i] += matriz[i * n + j] * vec[j];
    vec = temp; 
}
</code></pre>
<p><strong>Función que resuelve el sistema tridiagonal usando el método de Thomas</strong></p>
<p>Se resuelve el sistema de ecuaciones lineales obtenido, el cual incluye una matriz tridiagonal, utilizando el método de Thomas. La solución se almacena en el vector u, sobrescribiendo así su contenido.</p>
<p><code>T</code> Matriz tridiagonal resuelta por medio del método de Thomas, y almacenada de forma 1D.</p>
<p><code>u</code> Vector con los términos independientes del sistema tridiagonal.</p>
<p><code>n</code> Dimensión de la matriz.</p>
<p>El resultado final se guarda en el vector <code>u</code>.</p>
<pre><code class="language-cpp">void resolverTridiagonal(const std::vector&lt;double&gt;&amp; T, std::vector&lt;double&gt;&amp; u, int n) {
    std::vector&lt;double&gt; a(n, 0.0), b(n, 0.0), c(n, 0.0), x(n, 0.0);
    for (int i = 0; i &lt; n; i++) b[i] = T[i * n + i];
    for (int i = 0; i &lt; n-1; i++) {
        a[i+1] = T[(i+1) * n + i];
        c[i] = T[i * n + (i + 1)];
    }
    c[0] /= b[0];
    x[0] = u[0] / b[0];
    for (int i = 1; i &lt; n; i++) {
        double m = b[i] - a[i] * c[i-1];
        c[i] /= m;
        x[i] = (u[i] - a[i] * x[i-1]) / m;
    }
    for (int i = n - 2; i &gt;= 0; i--)
        x[i] -= c[i] * x[i + 1];
    u = x;
}
</code></pre>
<p><strong>Función que crea una matriz tridiagonal implicita</strong></p>
<p>Se crea una matriz tridiagonal implícita con valores 1+2r en la diagonal principal y -r en las otras dos diagonales.</p>
<p><code>n</code> Dimensión de la matriz.</p>
<p><code>r</code> Valor de la variable discretizada que relaciona la parte espacial y temporal de la ecuación diferencial.</p>
<p><code>return Laplaciano</code> Se retorna un Laplaciano tridiagonal implícito nxn.</p>
<pre><code class="language-cpp">std::vector&lt;double&gt; crearLaplacianoImplicito(int n, double r) {
    std::vector&lt;double&gt; Laplaciano(n * n, 0.0);
    for (int i = 0; i &lt; n; ++i) {
        if (i == 0 || i == n - 1) {
            Laplaciano[i * n + i] = 1.0;
        } else {
            Laplaciano[i * n + (i - 1)] = -r;
            Laplaciano[i * n + i] = 1 + 2 * r;
            Laplaciano[i * n + (i + 1)] = -r;
        }
    }
    return Laplaciano;
}
</code></pre>
<p><strong>Función que crea una matriz tridiagonal explicita</strong></p>
<p>Se crea una matriz tridiagonal explícita con valores 1-2r en la diagonal principal y r en las otras dos diagonales.</p>
<p><code>n</code> Dimensión de la matriz.</p>
<p><code>r</code> Valor de la variable discretizada que relaciona la parte espacial y temporal de la ecuación diferencial.</p>
<p><code>return Laplaciano</code> Se retorna un Laplaciano tridiagonal explícito nxn.</p>
<pre><code class="language-cpp">std::vector&lt;double&gt; crearLaplacianoExplicito(int n, double r) {
    std::vector&lt;double&gt; Laplaciano(n * n, 0.0);
    for (int i = 0; i &lt; n; ++i) {
        if (i == 0 || i == n - 1) {
            Laplaciano[i * n + i] = 1;
        } else {
            Laplaciano[i * n + (i - 1)] = r;
            Laplaciano[i * n + i] = 1 - 2 * r;
            Laplaciano[i * n + (i + 1)] = r;
        }
    }
    return  Laplaciano;
}
</code></pre>
<p><strong>Función que calcula el método de Crank Nicholson con Alternating Direction Implicit (ADI)</strong></p>
<p>La función resuelve la ecuación de calor en 2D dividiendo la parte temporal de problema en 2 subpasos:
Una parte para la dirección y y otra para la dirección x. Esto facilita poder utilizar el método de Crank
Nicholson al reducirlo con matrices tridiagonales. Además en cada subpaso se calcula la multiplicación de de matrices y la resolución de la matriz tridiagonal por medio del método de Thomas.</p>
<p>Para la parte de la paralelización se utilizó estratégicamente en los bucles for que involucran filas y columnas  de la malla, ya que al agregarlo en dichos <code>for</code>, la velocidad del código mejora considerablemente.</p>
<p><code>matriz</code> Matriz almacenada como un vector 1D.</p>
<p><code>n</code> Número de puntos a utilizar.</p>
<p><code>r</code> Valor de la variable discretizada que relaciona la parte espacial y temporal de la ecuación diferencial.</p>
<p><code>pasos</code> Número de pasos a utilizar.</p>
<p><code>bordeIzq</code> Valor de frontera en el borde izquierdo.</p>
<p><code>bordeDer</code> Valor de frontera en el borde derecho.</p>
<p><code>bordeInf</code> Valor de frontera del borde inferior.</p>
<p><code>bordeSup</code> Valor de frontera del borde superior.</p>
<pre><code class="language-cpp">void CN_2D_ADI_Advance(std::vector&lt;double&gt;&amp; matriz, int n, double r, int pasos,
                       double bordeIzq, double bordeDer, double bordeInf, double bordeSup) {

    r = r / 2.0;
    std::vector&lt;double&gt; S = crearLaplacianoExplicito(n, r);
    std::vector&lt;double&gt; T = crearLaplacianoImplicito(n, r);
    std::vector&lt;double&gt; temp(n * n, 0.0);
    std::vector&lt;double&gt; fila(n);
    std::vector&lt;double&gt; columna(n);

    for (int t = 0; t &lt; pasos; ++t) {

        # pragma omp parallel for
        for (int i = 0; i &lt; n; ++i) {
          std::vector&lt;double&gt; fila(n);
          for (int j = 0; j &lt; n; ++j)
            fila[j] = matriz[i * n +j];
          multiplicarMatrizVector(S, fila, n);
          for (int j = 0; j &lt; n; ++j)
            matriz[i * n +j] = fila[j];
        }


        # pragma omp parallel for
        for (int j = 0; j &lt; n; ++j) {
            std::vector&lt;double&gt; columna(n);
            for (int i = 0; i &lt; n; ++i)
                columna[i] = matriz[i * n + j];
            resolverTridiagonal(T, columna, n);
            for (int i = 0; i &lt; n; ++i)
                matriz[i * n + j] = columna[i];
        }



        # pragma omp parallel for
        for (int j = 0; j &lt; n; ++j) {
          std::vector&lt;double&gt; columna(n);
          for (int i = 0; i &lt; n; ++i)
            columna[i] = matriz[i * n +j];
          multiplicarMatrizVector(S, columna, n);
          for (int i = 0; i &lt; n; ++i)
            matriz[i * n + j] = columna[i];
        }



        # pragma omp parallel for
        for (int i = 0; i &lt; n; ++i) {
            std::vector&lt;double&gt; fila(n);
            for (int j = 0; j &lt; n; ++j)
                fila[j] = matriz[i * n +j];
            resolverTridiagonal(T, fila, n);
            for (int j = 0; j &lt; n; ++j)
                matriz[i * n + j] = fila[j];
        }
    }
}
</code></pre>
<p><strong>Clase</strong> </p>
<p><code>solucion_ecuacion_calor</code> Consiste en los procesos necesarios para resolver el problema.</p>
<p>En esta se configuran las condiciones iniciales y de frontera, además de que se crean las funciones con las cuáles se calcula la solución del 
problema.</p>
<p><strong>Atributos</strong>
- <code>n, dt, t, alpha2, ds, r, pasos</code>: parámetros numéricos.
- <code>opcion</code>: condición inicial seleccionada.
- <code>condicion_frontera</code>: tipo de borde (1: Dirichlet, 2: Neumann, 3: Robin).
- <code>matriz</code>: contiene los valores de temperatura.</p>
<p><strong>Funciones privadas</strong></p>
<pre><code class="language-cpp">private:
    int n;
    int pasos;
    double dt, t;
    double ds;
    double r;
    double alpha2;
    int opcion;
    int condicion_frontera;
    std::vector&lt;double&gt; matriz;

    double evaluar_condicion_ini(double x, double y) {
        if (opcion == 1) {
          //Condición inicial de pulso gaussiano centrado.
            double dx = x - 0.5;
            double dy = y - 0.5;
            return exp(-100 * (dx * dx + dy * dy));
        } else if (opcion == 2) {
          // Condición inicial de paraboloide centrado
            double dx = x - 0.5;
            double dy = y - 0.5;
            return 10.0 * (dx * dx + dy * dy);
        } else if (opcion == 3) {
          // Condición inicial de la onda senoidal suave
            const double Pi = 3.1415926535;
            return sin(2 * Pi * x) * sin(2 * Pi * y);
        }
        return 0.0;
    }
</code></pre>
<p><strong>Funciones públicas</strong></p>
<p><code>solucion_ecuacion_calor(int n, double dt, double t, double alpha2 = 1.0)</code></p>
<p><code>void opcion_escogida(int opcion_variable)</code></p>
<p><code>void condicion_front_escog(int condicion)</code></p>
<p><code>void aplicar_condicion_inicial()</code></p>
<p><code>void evaluar_condicion_frontera()</code></p>
<p><code>void resolver()</code></p>
<p><code>void imprimir()</code></p>
<p><code>solucion_ecuacion_calor()</code> inicializa todos los parámetros necesarios para simular la ecuación de calor en dos dimensiones. Recibe el tamaño de la malla <code>n_variable</code>, el tamaño del paso temporal (<code>dt_variable</code>), el tiempo total de simulación <code>t_variable</code> y la difusividad térmica <code>alpha2_variable</code>, que por defecto es 1.0. </p>
<p>A partir de estos valores, calcula el espaciamiento entre puntos <code>ds = 1/(n-1)</code>, el número de pasos de tiempo <code>pasos = t/dt</code> y el número adimensional <code>$r = \alpha^2·\frac{dt}/{ds}^2$</code> que son muy importantes para la estabilidad del método.</p>
<p><code>condicion_front_escog()</code> guarda la condición de frontera elegida por el usuario; Dirichlet, Neumann o Robin.</p>
<p><code>opcion_escogida()</code> registra la forma de la condición inicial; pulso gaussiano, paraboloide centrado o onda senoidal suave.</p>
<p><code>aplicar_condicion_inicial()</code> recorre cada punto de la malla 2D, calcula sus coordenadas espaciales <code>(x, y)</code> y les asigna un valor inicial de temperatura evaluando la función correspondiente.</p>
<pre><code class="language-cpp">public:
    //Se crea un constructor:
    solucion_ecuacion_calor(int n_variable, double dt_variable, double t_variable, double alpha2_variable = 1.0) {
        n = n_variable;
        dt = dt_variable;
        t = t_variable;
        alpha2 = alpha2_variable;
        ds = 1.0 / (n - 1);
        r = alpha2 * dt / (ds * ds);
        pasos = static_cast&lt;int&gt;(t / dt);
        matriz = crearMatrizCeros(n, n);
    }

    // Se guarda la opcion escogida para la condición de frontera en la variable condicion_frontera.
    void condicion_front_escog(int condicion) {
        condicion_frontera = condicion;
    }

    // Se guarda la opcion escogida para la condición inicial en la variable opcion
    void opcion_escogida(int opcion_variable) {
        opcion = opcion_variable;
    }
     // Se aplica la condición inicial escogida
    void aplicar_condicion_inicial() {
        for (int j = 0; j &lt; n; ++j) {
            for (int i = 0; i &lt; n; ++i) {
                double x = i * ds;
                double y = j * ds;
                matriz[j * n + i] = evaluar_condicion_ini(x, y);
            }
        }
    }
</code></pre>
<p><code>evaluar_condicion_frontera()</code> aplica el tipo de condición de frontera seleccionado por el usuario a la malla de temperatura.</p>
<p>Si se selecciona la condición <strong>Dirichlet</strong> (<code>condicion_frontera == 1</code>), se fija la temperatura en los bordes a cero, simulando que los bordes se mantienen fríos permanentemente. </p>
<p>En la condición <strong>Neumann</strong> (<code>condicion_frontera == 2</code>), se igualan los valores de los bordes a los de sus vecinos interiores, lo que representa un flujo de calor nulo a través de las fronteras. </p>
<p>La condición <strong>Robin</strong> (<code>condicion_frontera == 3</code>) combina las dos anteriores e impone que los bordes pierdan calor hacia el entorno, ajustando los valores según un factor físico <code>beta</code> que simula una pérdida proporcional a la diferencia de temperatura entre el borde y su entorno. Esta condición es común cuando hay transferencia de calor por convección en los bordes. </p>
<pre><code class="language-cpp">// Se evalúa la condición de frontera correspondiente
    void evaluar_condicion_frontera() {
        double beta = 3.0;
        for (int i = 0; i &lt; n; ++i) {
            if (condicion_frontera == 1) {
                matriz[i * n + 0] = 0;
                matriz[i * n + (n - 1)] = 0;
                matriz[0 * n + i] = 0;
                matriz[(n - 1) * n + i] = 0;
            } else if (condicion_frontera == 2) {
                matriz[i * n + 0] = matriz[i * n + 1];
                matriz[i * n + (n - 1)] = matriz[i * n + (n - 2)];
                matriz[0 * n + i] = matriz[1 * n + i];
                matriz[(n - 1) * n + i] = matriz[(n - 2) * n + i];
            } else if (condicion_frontera == 3) {
                matriz[i * n + 0] = matriz[i * n + 1] / (1 + beta * ds);
                matriz[i * n + (n - 1)] = matriz[i * n + (n - 2)] / (1 + beta * ds);
                matriz[0 * n + i] = matriz[1 * n + i] / (1 + beta * ds);
                matriz[(n - 1) * n + i] = matriz[(n - 2) * n + i] / (1 + beta * ds);
            }
        }
    }

    void resolver() {
        for (int paso = 0; paso &lt; pasos; ++paso) {
            evaluar_condicion_frontera();
            CN_2D_ADI_Advance(matriz, n, r, 1, 0, 0, 0, 0);
        }
    }

    void imprimir() {
        imprimirMatriz(matriz, n);
    }
};
</code></pre>
<p><strong>Función main</strong></p>
<p>Inicializa todo el código para resolver la ecuación de calor en 2-D. Para esto el usuario primero debe de escoger una de las tres condiciones iniciales y una de las tres condiciones de frontera. El programa evalúa dicha condición incial usando el método de Crank Nicholson y la reducción de la matriz tridiagonal con el método de Thomas, y luego imprime el resultado obtenido.</p>
<p><code>return 0</code> si el programa se ejecuta sin ningún problema, y 1 si la opción elegida no era válida.</p>
<pre><code class="language-cpp">int main() {
    int ns = 50;
    double dt = 0.0005, t = 0.1;

    int opcion_cond_ini;
    std::cout &lt;&lt; &quot;Escoja una de las siguientes condiciones iniciales al ingresar el número correspondiente: \n&quot;;
    std::cout &lt;&lt; &quot; 1. Pulso Gaussiano centrado \n2. Paraboloide centrado \n3. Onda senoidal suave \n&quot;;
    std::cin &gt;&gt; opcion_cond_ini;

    int condicion_frontera;
    std::cout &lt;&lt; &quot;Escoja una de las siguientes condiciones de frontera al ingresar el número correspondiente: \n&quot;;
    std::cout &lt;&lt; &quot; 1. Dirichlet \n2. Neuman \n3. Robin \n&quot;;
    std::cin &gt;&gt; condicion_frontera;

    if (opcion_cond_ini &lt; 1 || opcion_cond_ini &gt; 3) {
        std::cerr &lt;&lt; &quot;La opción elegida no es válida. \n&quot;;
        return 1;
    }

    // Se crea el constructor y se usa para llamar las funciones.
    solucion_ecuacion_calor constructor(ns, dt, t);
    constructor.opcion_escogida(opcion_cond_ini);
    constructor.condicion_front_escog(condicion_frontera);
    constructor.aplicar_condicion_inicial();
    constructor.resolver();
    constructor.imprimir();

    return 0;
}
</code></pre>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.f8cc74c7.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.c8b220af.min.js"></script>
      
        <script src="../javascripts/mathjax.js"></script>
      
        <script src="https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>