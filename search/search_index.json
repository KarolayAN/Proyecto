{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Ecuaci\u00f3n de Calor en 2D","text":"<p>Universidad de Costa Rica</p> <p>Proyecto Final de F\u00edsica Computacional</p> <p>I Semestre 2025</p> <p>El repositorio del proyecto puede ser consultado en: https://github.com/KarolayAN/Proyecto</p> <p>Nombre de los estudiantes:</p> <p>Alba Sofia Rojas Doza (C36873)</p> <p>Oscar Alvarez Poveda (C003949) </p> <p>Ricardo Jose Suarez Sancho (C17810)</p> <p>Karolay Alvarado Navarro (C20359)</p> <p>Julio 2025</p>"},{"location":"#introduccion","title":"Introduccion","text":"<p>La ecuaci\u00f3n de calor en dos dimensiones es una ecuaci\u00f3n en derivadas parciales de segundo orden que describe la evoluci\u00f3n temporal de la temperatura en una regi\u00f3n del espacio bajo condiciones f\u00edsicas ideales. Esta ecuaci\u00f3n toma la forma:</p> <p>\\(\\frac{\\partial u}{\\partial t} = c^2 \\left( \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} \\right)\\)</p> <p>en donde \\(u(x,y,t)\\) representa la temperatura en la posicion \\((x,y)\\) en el tiempo \\(t\\), \\(c\\) es una constante que depende del material y \\(\\Delta^2\\) es el operador Laplaciano, que en dos dimensiones que viene de la expresi\u00f3n:</p> <p>\\(\\Delta^2u = \\left( \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} \\right)\\)</p> <p>Este modelo es v\u00e1lido bajo condiciones ideales, como materiales homog\u00e9neos, sin fuentes de calor internas y con propiedades t\u00e9rmicas constantes. La ecuaci\u00f3n se utiliza para modelar la transferencia de calor en placas, l\u00e1minas y superficies, siendo fundamental en campos como la ingenier\u00eda, la geof\u00edsica, la medicina y la ciencia de materiales.</p> <p>Adem\u00e1s,  permite analizar el comportamiento t\u00e9rmico de sistemas bidimensionales sujetos a distintas condiciones iniciales y de frontera.</p> <p>En el desarrollo del proyecto, se resolvera dicha ecuaci\u00f3n tanto en Python como en C++, aplicando as\u00ed pr\u00e1cticas estudiadas en el curso, como el uso apropiado de recursos de memoria, prinicipios de programacion orientada a objetos, paralelismo en memoria compartida, la documentacion y control de versiones con Git. </p> <p>Asimismo, debemos de experimentar con diferentes condiciones inciales y de frontera, y visualizar la evolucion temporal de la temperatura mediante mapas de colores. </p>"},{"location":"bibliografia/","title":"Bibligraf\u00eda","text":""},{"location":"bibliografia/#referencias-bibliograficas","title":"Referencias Bibliogr\u00e1ficas","text":"<p>[1] Morton, K &amp; Mayers, D. Numerical Solution of Partial Differential Equations Cambridge University Pres. 2nd Edition (2005).</p> <p>[2] M. Newman, Computational Physics, CreateSpace, DC, USA, 1st Edition (2013) .</p> <p>[3] Recktenwald, G. Finite-Difference Approximations to the Heat Equation. Mechanical Engineering. (2004).</p> <p>[4] Su, V. Finite Difference Methods Applied to the Heat Equation in 1D and 2D. (2013).</p>"},{"location":"c%2B%2B/","title":"Soluci\u00f3n en C++","text":"<p>El presente c\u00f3digo en C++ tiene como objetivo resolver la ecuaci\u00f3n de calor en dos dimensiones. Para resolverla de forma eficiente, el c\u00f3digo implementa el m\u00e9todo Crank\u2013Nicolson con Alternating Direction Implicit (ADI). Este m\u00e9todo permite dividir cada paso temporal en dos subpasos alternados en direcci\u00f3n horizontal y vertical, facilitando la resoluci\u00f3n de matrices tridiagonales mediante el eficiente m\u00e9todo de Thomas.</p> <p>Adem\u00e1s, se integran t\u00e9cnicas de paralelismo de memoria compartida usando OpenMP, lo que permite reducir significativamente los tiempos de c\u00e1lculo. El c\u00f3digo est\u00e1 dise\u00f1ado para permitir la elecci\u00f3n entre distintas condiciones iniciales</p> <p>La siguiente funci\u00f3n crea una matriz representada como un vector de 1D:</p> <p>Se utilizaron las siguientes bibliotecas:</p> <ul> <li> <p><code>&lt;iostream&gt;</code>: Para poder utilizar inputs y outputs con std.</p> </li> <li> <p><code>&lt;cmath&gt;</code>: Para poder agregar funciones matem\u00e1ticas</p> </li> <li> <p><code>&lt;vector&gt;</code>: Para poder usar std::vector</p> </li> <li> <p><code>&lt;omp.h&gt;</code>: Para paralelizar con OpenMP</p> </li> </ul> <pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n#include &lt;vector&gt;\n#include &lt;omp.h&gt;\n</code></pre> <p>Funci\u00f3n que crea una matriz llena de ceros, y la almacena en 1 vector de 1D</p> <p><code>crearMatrizCeros(int n, int m)</code> genera una matriz de ceros con <code>n</code> filas y <code>m</code> columnas, representada como un vector unidimensional (<code>std::vector&lt;double&gt;</code>) de tama\u00f1o <code>n \u00d7 m</code>. </p> <p><code>[i * n + j]</code> convierte coordenadas bidimensionales (i, j) fila y columna de una matriz 2D, en una posici\u00f3n dentro de un vector de una sola dimensi\u00f3n (1D).</p> <p><code>[i * n + j]</code> se utiliza para convertir coordenadas bidimensionales <code>(i, j)</code> donde <code>i</code> representa la fila y <code>j</code> la columna en una \u00fanica posici\u00f3n dentro de un vector unidimensional que simula una matriz 2D. En este contexto, <code>n</code> es el n\u00famero total de columnas. Esto permite representar matrices como arreglos lineales de una sola dimensi\u00f3n, lo cual es m\u00e1s eficiente en t\u00e9rminos de memoria y procesamiento.</p> <p>Todos los valores se inicializan en cero (<code>0.0</code>), lo que es importante para establecer una temperatura base uniforme</p> <pre><code>std::vector&lt;double&gt; crearMatrizCeros(int n, int m) {\n    return std::vector&lt;double&gt;(n * m, 0.0);\n}\n</code></pre> <p>Funci\u00f3n que imprime la matriz creada anteriormente</p> <p>Se imprime en la consola la matriz nxn contenida en un vector de 1D. Para esto se utilzan 3 cifras decimales por cada entrada de la matriz.</p> <p><code>matriz</code> Vector que contiene la matriz creada previamente de forma lineal.</p> <p><code>n</code> N\u00famero de filas de la matriz.</p> <pre><code>void imprimirMatriz(const std::vector&lt;double&gt;&amp; matriz, int n) {\n    for (int i = 0; i &lt; n; ++i) {\n        for (int j = 0; j &lt; n; ++j) {\n            printf(\"%.3f \", matriz[i * n + j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}\n</code></pre> <p>Funci\u00f3n que multiplica la matriz anteior por un vector.</p> <p>Se hace una multiplicaci\u00f3n entre la matriz guardada en el vector 1D y un vector de las mismas dimensiones.  El resultado obtenido de la multiplicaci\u00f3n sobreescribe el vector original utilizado.</p> <p><code>matriz</code> Vector que contiene la matriz creada previamente de forma lineal.</p> <p><code>vec</code> Vector por el cual se multiplica la matriz, y en el cual se guardan los resultados de la multiplicaci\u00f3n.</p> <p><code>n</code> N\u00famero de filas de la matriz.</p> <pre><code>void multiplicarMatrizVector(const std::vector&lt;double&gt;&amp; matriz, std::vector&lt;double&gt;&amp; vec, int n) {\n    std::vector&lt;double&gt; temp(n, 0.0);\n    for (int i = 0; i &lt; n; ++i)\n        for (int j = 0; j &lt; n; ++j)\n            temp[i] += matriz[i * n + j] * vec[j];\n    vec = temp; \n}\n</code></pre> <p>Funci\u00f3n que resuelve el sistema tridiagonal usando el m\u00e9todo de Thomas</p> <p>Se resuelve el sistema de ecuaciones lineales obtenido, el cual incluye una matriz tridiagonal, utilizando el m\u00e9todo de Thomas. La soluci\u00f3n se almacena en el vector u, sobrescribiendo as\u00ed su contenido.</p> <p><code>T</code> Matriz tridiagonal resuelta por medio del m\u00e9todo de Thomas, y almacenada de forma 1D.</p> <p><code>u</code> Vector con los t\u00e9rminos independientes del sistema tridiagonal.</p> <p><code>n</code> Dimensi\u00f3n de la matriz.</p> <p>El resultado final se guarda en el vector <code>u</code>.</p> <pre><code>void resolverTridiagonal(const std::vector&lt;double&gt;&amp; T, std::vector&lt;double&gt;&amp; u, int n) {\n    std::vector&lt;double&gt; a(n, 0.0), b(n, 0.0), c(n, 0.0), x(n, 0.0);\n    for (int i = 0; i &lt; n; i++) b[i] = T[i * n + i];\n    for (int i = 0; i &lt; n-1; i++) {\n        a[i+1] = T[(i+1) * n + i];\n        c[i] = T[i * n + (i + 1)];\n    }\n    c[0] /= b[0];\n    x[0] = u[0] / b[0];\n    for (int i = 1; i &lt; n; i++) {\n        double m = b[i] - a[i] * c[i-1];\n        c[i] /= m;\n        x[i] = (u[i] - a[i] * x[i-1]) / m;\n    }\n    for (int i = n - 2; i &gt;= 0; i--)\n        x[i] -= c[i] * x[i + 1];\n    u = x;\n}\n</code></pre> <p>Funci\u00f3n que crea una matriz tridiagonal implicita</p> <p>Se crea una matriz tridiagonal impl\u00edcita con valores 1+2r en la diagonal principal y -r en las otras dos diagonales.</p> <p><code>n</code> Dimensi\u00f3n de la matriz.</p> <p><code>r</code> Valor de la variable discretizada que relaciona la parte espacial y temporal de la ecuaci\u00f3n diferencial.</p> <p><code>return Laplaciano</code> Se retorna un Laplaciano tridiagonal impl\u00edcito nxn.</p> <pre><code>std::vector&lt;double&gt; crearLaplacianoImplicito(int n, double r) {\n    std::vector&lt;double&gt; Laplaciano(n * n, 0.0);\n    for (int i = 0; i &lt; n; ++i) {\n        if (i == 0 || i == n - 1) {\n            Laplaciano[i * n + i] = 1.0;\n        } else {\n            Laplaciano[i * n + (i - 1)] = -r;\n            Laplaciano[i * n + i] = 1 + 2 * r;\n            Laplaciano[i * n + (i + 1)] = -r;\n        }\n    }\n    return Laplaciano;\n}\n</code></pre> <p>Funci\u00f3n que crea una matriz tridiagonal explicita</p> <p>Se crea una matriz tridiagonal expl\u00edcita con valores 1-2r en la diagonal principal y r en las otras dos diagonales.</p> <p><code>n</code> Dimensi\u00f3n de la matriz.</p> <p><code>r</code> Valor de la variable discretizada que relaciona la parte espacial y temporal de la ecuaci\u00f3n diferencial.</p> <p><code>return Laplaciano</code> Se retorna un Laplaciano tridiagonal expl\u00edcito nxn.</p> <pre><code>std::vector&lt;double&gt; crearLaplacianoExplicito(int n, double r) {\n    std::vector&lt;double&gt; Laplaciano(n * n, 0.0);\n    for (int i = 0; i &lt; n; ++i) {\n        if (i == 0 || i == n - 1) {\n            Laplaciano[i * n + i] = 1;\n        } else {\n            Laplaciano[i * n + (i - 1)] = r;\n            Laplaciano[i * n + i] = 1 - 2 * r;\n            Laplaciano[i * n + (i + 1)] = r;\n        }\n    }\n    return  Laplaciano;\n}\n</code></pre> <p>Funci\u00f3n que calcula el m\u00e9todo de Crank Nicholson con Alternating Direction Implicit (ADI)</p> <p>La funci\u00f3n resuelve la ecuaci\u00f3n de calor en 2D dividiendo la parte temporal de problema en 2 subpasos: Una parte para la direcci\u00f3n y y otra para la direcci\u00f3n x. Esto facilita poder utilizar el m\u00e9todo de Crank Nicholson al reducirlo con matrices tridiagonales. Adem\u00e1s en cada subpaso se calcula la multiplicaci\u00f3n de de matrices y la resoluci\u00f3n de la matriz tridiagonal por medio del m\u00e9todo de Thomas.</p> <p>Para la parte de la paralelizaci\u00f3n se utiliz\u00f3 estrat\u00e9gicamente en los bucles for que involucran filas y columnas  de la malla, ya que al agregarlo en dichos <code>for</code>, la velocidad del c\u00f3digo mejora considerablemente.</p> <p><code>matriz</code> Matriz almacenada como un vector 1D.</p> <p><code>n</code> N\u00famero de puntos a utilizar.</p> <p><code>r</code> Valor de la variable discretizada que relaciona la parte espacial y temporal de la ecuaci\u00f3n diferencial.</p> <p><code>pasos</code> N\u00famero de pasos a utilizar.</p> <p><code>bordeIzq</code> Valor de frontera en el borde izquierdo.</p> <p><code>bordeDer</code> Valor de frontera en el borde derecho.</p> <p><code>bordeInf</code> Valor de frontera del borde inferior.</p> <p><code>bordeSup</code> Valor de frontera del borde superior.</p> <pre><code>void CN_2D_ADI_Advance(std::vector&lt;double&gt;&amp; matriz, int n, double r, int pasos,\n                       double bordeIzq, double bordeDer, double bordeInf, double bordeSup) {\n\n    r = r / 2.0;\n    std::vector&lt;double&gt; S = crearLaplacianoExplicito(n, r);\n    std::vector&lt;double&gt; T = crearLaplacianoImplicito(n, r);\n    std::vector&lt;double&gt; temp(n * n, 0.0);\n    std::vector&lt;double&gt; fila(n);\n    std::vector&lt;double&gt; columna(n);\n\n    for (int t = 0; t &lt; pasos; ++t) {\n\n        # pragma omp parallel for\n        for (int i = 0; i &lt; n; ++i) {\n          std::vector&lt;double&gt; fila(n);\n          for (int j = 0; j &lt; n; ++j)\n            fila[j] = matriz[i * n +j];\n          multiplicarMatrizVector(S, fila, n);\n          for (int j = 0; j &lt; n; ++j)\n            matriz[i * n +j] = fila[j];\n        }\n\n\n        # pragma omp parallel for\n        for (int j = 0; j &lt; n; ++j) {\n            std::vector&lt;double&gt; columna(n);\n            for (int i = 0; i &lt; n; ++i)\n                columna[i] = matriz[i * n + j];\n            resolverTridiagonal(T, columna, n);\n            for (int i = 0; i &lt; n; ++i)\n                matriz[i * n + j] = columna[i];\n        }\n\n\n\n        # pragma omp parallel for\n        for (int j = 0; j &lt; n; ++j) {\n          std::vector&lt;double&gt; columna(n);\n          for (int i = 0; i &lt; n; ++i)\n            columna[i] = matriz[i * n +j];\n          multiplicarMatrizVector(S, columna, n);\n          for (int i = 0; i &lt; n; ++i)\n            matriz[i * n + j] = columna[i];\n        }\n\n\n\n        # pragma omp parallel for\n        for (int i = 0; i &lt; n; ++i) {\n            std::vector&lt;double&gt; fila(n);\n            for (int j = 0; j &lt; n; ++j)\n                fila[j] = matriz[i * n +j];\n            resolverTridiagonal(T, fila, n);\n            for (int j = 0; j &lt; n; ++j)\n                matriz[i * n + j] = fila[j];\n        }\n    }\n}\n</code></pre> <p>Clase </p> <p><code>solucion_ecuacion_calor</code> Consiste en los procesos necesarios para resolver el problema.</p> <p>En esta se configuran las condiciones iniciales y de frontera, adem\u00e1s de que se crean las funciones con las cu\u00e1les se calcula la soluci\u00f3n del  problema.</p> <p>Atributos - <code>n, dt, t, alpha2, ds, r, pasos</code>: par\u00e1metros num\u00e9ricos. - <code>opcion</code>: condici\u00f3n inicial seleccionada. - <code>condicion_frontera</code>: tipo de borde (1: Dirichlet, 2: Neumann, 3: Robin). - <code>matriz</code>: contiene los valores de temperatura.</p> <p>Funciones privadas</p> <pre><code>private:\n    int n;\n    int pasos;\n    double dt, t;\n    double ds;\n    double r;\n    double alpha2;\n    int opcion;\n    int condicion_frontera;\n    std::vector&lt;double&gt; matriz;\n\n    double evaluar_condicion_ini(double x, double y) {\n        if (opcion == 1) {\n          //Condici\u00f3n inicial de pulso gaussiano centrado.\n            double dx = x - 0.5;\n            double dy = y - 0.5;\n            return exp(-100 * (dx * dx + dy * dy));\n        } else if (opcion == 2) {\n          // Condici\u00f3n inicial de paraboloide centrado\n            double dx = x - 0.5;\n            double dy = y - 0.5;\n            return 10.0 * (dx * dx + dy * dy);\n        } else if (opcion == 3) {\n          // Condici\u00f3n inicial de la onda senoidal suave\n            const double Pi = 3.1415926535;\n            return sin(2 * Pi * x) * sin(2 * Pi * y);\n        }\n        return 0.0;\n    }\n</code></pre> <p>Funciones p\u00fablicas</p> <p><code>solucion_ecuacion_calor(int n, double dt, double t, double alpha2 = 1.0)</code></p> <p><code>void opcion_escogida(int opcion_variable)</code></p> <p><code>void condicion_front_escog(int condicion)</code></p> <p><code>void aplicar_condicion_inicial()</code></p> <p><code>void evaluar_condicion_frontera()</code></p> <p><code>void resolver()</code></p> <p><code>void imprimir()</code></p> <p><code>solucion_ecuacion_calor()</code> inicializa todos los par\u00e1metros necesarios para simular la ecuaci\u00f3n de calor en dos dimensiones. Recibe el tama\u00f1o de la malla <code>n_variable</code>, el tama\u00f1o del paso temporal (<code>dt_variable</code>), el tiempo total de simulaci\u00f3n <code>t_variable</code> y la difusividad t\u00e9rmica <code>alpha2_variable</code>, que por defecto es 1.0. </p> <p>A partir de estos valores, calcula el espaciamiento entre puntos <code>ds = 1/(n-1)</code>, el n\u00famero de pasos de tiempo <code>pasos = t/dt</code> y el n\u00famero adimensional <code>$r = \\alpha^2\u00b7\\frac{dt}/{ds}^2$</code> que son muy importantes para la estabilidad del m\u00e9todo.</p> <p><code>condicion_front_escog()</code> guarda la condici\u00f3n de frontera elegida por el usuario; Dirichlet, Neumann o Robin.</p> <p><code>opcion_escogida()</code> registra la forma de la condici\u00f3n inicial; pulso gaussiano, paraboloide centrado o onda senoidal suave.</p> <p><code>aplicar_condicion_inicial()</code> recorre cada punto de la malla 2D, calcula sus coordenadas espaciales <code>(x, y)</code> y les asigna un valor inicial de temperatura evaluando la funci\u00f3n correspondiente.</p> <pre><code>public:\n    //Se crea un constructor:\n    solucion_ecuacion_calor(int n_variable, double dt_variable, double t_variable, double alpha2_variable = 1.0) {\n        n = n_variable;\n        dt = dt_variable;\n        t = t_variable;\n        alpha2 = alpha2_variable;\n        ds = 1.0 / (n - 1);\n        r = alpha2 * dt / (ds * ds);\n        pasos = static_cast&lt;int&gt;(t / dt);\n        matriz = crearMatrizCeros(n, n);\n    }\n\n    // Se guarda la opcion escogida para la condici\u00f3n de frontera en la variable condicion_frontera.\n    void condicion_front_escog(int condicion) {\n        condicion_frontera = condicion;\n    }\n\n    // Se guarda la opcion escogida para la condici\u00f3n inicial en la variable opcion\n    void opcion_escogida(int opcion_variable) {\n        opcion = opcion_variable;\n    }\n     // Se aplica la condici\u00f3n inicial escogida\n    void aplicar_condicion_inicial() {\n        for (int j = 0; j &lt; n; ++j) {\n            for (int i = 0; i &lt; n; ++i) {\n                double x = i * ds;\n                double y = j * ds;\n                matriz[j * n + i] = evaluar_condicion_ini(x, y);\n            }\n        }\n    }\n</code></pre> <p><code>evaluar_condicion_frontera()</code> aplica el tipo de condici\u00f3n de frontera seleccionado por el usuario a la malla de temperatura.</p> <p>Si se selecciona la condici\u00f3n Dirichlet (<code>condicion_frontera == 1</code>), se fija la temperatura en los bordes a cero, simulando que los bordes se mantienen fr\u00edos permanentemente. </p> <p>En la condici\u00f3n Neumann (<code>condicion_frontera == 2</code>), se igualan los valores de los bordes a los de sus vecinos interiores, lo que representa un flujo de calor nulo a trav\u00e9s de las fronteras. </p> <p>La condici\u00f3n Robin (<code>condicion_frontera == 3</code>) combina las dos anteriores e impone que los bordes pierdan calor hacia el entorno, ajustando los valores seg\u00fan un factor f\u00edsico <code>beta</code> que simula una p\u00e9rdida proporcional a la diferencia de temperatura entre el borde y su entorno. Esta condici\u00f3n es com\u00fan cuando hay transferencia de calor por convecci\u00f3n en los bordes. </p> <pre><code>// Se eval\u00faa la condici\u00f3n de frontera correspondiente\n    void evaluar_condicion_frontera() {\n        double beta = 3.0;\n        for (int i = 0; i &lt; n; ++i) {\n            if (condicion_frontera == 1) {\n                matriz[i * n + 0] = 0;\n                matriz[i * n + (n - 1)] = 0;\n                matriz[0 * n + i] = 0;\n                matriz[(n - 1) * n + i] = 0;\n            } else if (condicion_frontera == 2) {\n                matriz[i * n + 0] = matriz[i * n + 1];\n                matriz[i * n + (n - 1)] = matriz[i * n + (n - 2)];\n                matriz[0 * n + i] = matriz[1 * n + i];\n                matriz[(n - 1) * n + i] = matriz[(n - 2) * n + i];\n            } else if (condicion_frontera == 3) {\n                matriz[i * n + 0] = matriz[i * n + 1] / (1 + beta * ds);\n                matriz[i * n + (n - 1)] = matriz[i * n + (n - 2)] / (1 + beta * ds);\n                matriz[0 * n + i] = matriz[1 * n + i] / (1 + beta * ds);\n                matriz[(n - 1) * n + i] = matriz[(n - 2) * n + i] / (1 + beta * ds);\n            }\n        }\n    }\n\n    void resolver() {\n        for (int paso = 0; paso &lt; pasos; ++paso) {\n            evaluar_condicion_frontera();\n            CN_2D_ADI_Advance(matriz, n, r, 1, 0, 0, 0, 0);\n        }\n    }\n\n    void imprimir() {\n        imprimirMatriz(matriz, n);\n    }\n};\n</code></pre> <p>Funci\u00f3n main</p> <p>Inicializa todo el c\u00f3digo para resolver la ecuaci\u00f3n de calor en 2-D. Para esto el usuario primero debe de escoger una de las tres condiciones iniciales y una de las tres condiciones de frontera. El programa eval\u00faa dicha condici\u00f3n incial usando el m\u00e9todo de Crank Nicholson y la reducci\u00f3n de la matriz tridiagonal con el m\u00e9todo de Thomas, y luego imprime el resultado obtenido.</p> <p><code>return 0</code> si el programa se ejecuta sin ning\u00fan problema, y 1 si la opci\u00f3n elegida no era v\u00e1lida.</p> <pre><code>int main() {\n    int ns = 50;\n    double dt = 0.0005, t = 0.1;\n\n    int opcion_cond_ini;\n    std::cout &lt;&lt; \"Escoja una de las siguientes condiciones iniciales al ingresar el n\u00famero correspondiente: \\n\";\n    std::cout &lt;&lt; \" 1. Pulso Gaussiano centrado \\n2. Paraboloide centrado \\n3. Onda senoidal suave \\n\";\n    std::cin &gt;&gt; opcion_cond_ini;\n\n    int condicion_frontera;\n    std::cout &lt;&lt; \"Escoja una de las siguientes condiciones de frontera al ingresar el n\u00famero correspondiente: \\n\";\n    std::cout &lt;&lt; \" 1. Dirichlet \\n2. Neuman \\n3. Robin \\n\";\n    std::cin &gt;&gt; condicion_frontera;\n\n    if (opcion_cond_ini &lt; 1 || opcion_cond_ini &gt; 3) {\n        std::cerr &lt;&lt; \"La opci\u00f3n elegida no es v\u00e1lida. \\n\";\n        return 1;\n    }\n\n    // Se crea el constructor y se usa para llamar las funciones.\n    solucion_ecuacion_calor constructor(ns, dt, t);\n    constructor.opcion_escogida(opcion_cond_ini);\n    constructor.condicion_front_escog(condicion_frontera);\n    constructor.aplicar_condicion_inicial();\n    constructor.resolver();\n    constructor.imprimir();\n\n    return 0;\n}\n</code></pre>"},{"location":"condiciones/","title":"Condiciones","text":""},{"location":"condiciones/#condiciones-iniciales","title":"Condiciones Iniciales","text":"<p>En la ecuacion de calor en 2D, las condiciones inciales definen como esta distribuida la temperatura en todo el dominio espacial en un tiempo inicial. Las condiciones inciales y de frontera son esenciales porque determinan completamente la evolucion temporal de la temperatura.  Las condiciones iniciales que se utilizaron para la resolucion de la ecuacion de calor en 2D son: </p> <p>1) Campana Gaussiana Centrada:</p> <p>Esta condicion simula una fuente de calor muy localizada, la temperatura es mas alta en el centro y disminuye rapidamente hacia los bordes. EL numero 100 en el exponente controla la concentracion de calor. Por lo que la campana Gaussiana centrada simula un calor concentrado, el cual es ideal para estudiar como se difunde el calor desde un punto. </p> <p>En Python:</p> <pre><code>    if tipo == 'gauss':\n            self.u[:, :] = np.exp(-100 * ((self.X - 0.5) ** 2 + (self.Y - 0.5) ** 2))\n</code></pre> <p>En C++:</p> <pre><code>double dx = x - 0.5;\n            double dy = y - 0.5;\n            return exp(-100 * (dx * dx + dy * dy));\n</code></pre> <p>2) Paraboloide Centrado:</p> <p>En esta condicion inicial, el centro esta mas frio y la temperatura aumenta hacia los bordes, como si las paredes externas calentaran la placa. El 10 es un factor de escala que controla que tan caliente estan los bordes. EL Paraboloide centrado es bueno para estudiar el flujo del calor del exterior hacia el centro. Cabe resaltar que esta condicion inicial es simetrica radialmente. </p> <p>En Python:</p> <pre><code>    elif tipo == 'paraboloide':\n            self.u[:, :] = 10 * ((self.X - 0.5) ** 2 + (self.Y - 0.5) ** 2)\n</code></pre> <p>En C++:</p> <pre><code>double dx = x - 0.5;\n            double dy = y - 0.5;\n            return 10.0 * (dx * dx + dy * dy);\n</code></pre> <p>3) Onda Senosoidal:</p> <p>La onda Senoidal simula el patron oscilante de calor; en donde la temperatura del dominio sube y baja de forma periodica. Esta condicion representa una superposicion de modos termicos y es muy util para ver como se disipan modos oscilatorios de calor en el tiempo. </p> <p>En Python:</p> <pre><code>    elif tipo == 'senoidal':\n            self.u[:, :] = np.sin(2 * np.pi * self.X) * np.sin(2 * np.pi * self.Y)\n</code></pre> <p>En C++:</p> <pre><code> const double Pi = 3.1415926535;\n            return sin(2 * Pi * x) * sin(2 * Pi * y);\n</code></pre>"},{"location":"condiciones/#condiciones-de-frontera","title":"Condiciones de Frontera","text":"<p>Al resolver la ecuacion de calor en 2D, se debe de decirle al programa que es lo que pasa con los bordes de la placa, y esas son las condiciones de frontera. A continuacion, se explicaran las condiciones de frontera que se utilizaron para resolver dicha ecuacion: </p> <p>1) Dirichlet:</p> <p>Dirichlet simula una placa conectada a un material o liquido que absorbe todo el calor que llega, los bordes del dominio estan en contacto con reservorios termicos que los mantienenm a una temperatura fija. Esta condicion de frontera es muy estable y comun en simulaciones.</p> <p>En Python:</p> <pre><code>    if frontera == 'dirichlet':\n                self.u_proxima[0, :] = 0 \n                self.u_proxima[-1, :] = 0 \n                self.u_proxima[:, 0] = 0 \n                self.u_proxima[:, -1] = 0 \n</code></pre> <p>En C++:</p> <pre><code>matriz[i * n + 0] = 0;\n                matriz[i * n + (n - 1)] = 0;\n                matriz[0 * n + i] = 0;\n                matriz[(n - 1) * n + i] = 0;\n</code></pre> <p>2) Neumann:</p> <p>Neumann simula que los bordes estan aislados termicamente, el calor no puede salir ni entrar por los bordes y no hay flujo de calor a traves de los bordes. Esto implica que no se conoce la temperatura en la frontera, sino el flujo de calor a trav\u00e9s de ella. En este caso, lo que se fija es la tasa de variaci\u00f3n de la temperatura en direcci\u00f3n perpendicular al borde del dominio. </p> <p>En Python:</p> <p>```py     elif frontera == 'neumann':                 self.u_proxima[0, :] = self.u_proxima[1, :]                  self.u_proxima[-1, :] = self.u_proxima[-2, :]                  self.u_proxima[:, 0] = self.u_proxima[:, 1]                  self.u_proxima[:, -1] = self.u_proxima[:, -2] </p> <pre><code>\nEn C++:\n\n```cpp\nmatriz[i * n + 0] = matriz[i * n + 1];\n                matriz[i * n + (n - 1)] = matriz[i * n + (n - 2)];\n                matriz[0 * n + i] = matriz[1 * n + i];\n                matriz[(n - 1) * n + i] = matriz[(n - 2) * n + i];\n</code></pre> <p>3) Robin:</p> <p>Robin es una condici\u00f3n mixta de Neumann y Dirichlet que modela un intercambio de calor con el ambiente exterior. El parametro beta es el coeficiente de conveccion, por lo que si beta es grande, se pierde calor mas rapido y si beta es peque\u00f1o, se pierde calor lentamente. Se establece una relaci\u00f3n entre la temperatura en la frontera y su derivada normal.</p> <p>En Python:</p> <pre><code>   elif frontera == 'robin':\n                beta = 3.0 \n                self.u_proxima[0, :] = self.u_proxima[1, :] / (1 + beta * self.dx) \n                self.u_proxima[-1, :] = self.u_proxima[-2, :] / (1 + beta * self.dx) \n                self.u_proxima[:, 0] = self.u_proxima[:, 1] / (1 + beta * self.dy) \n                self.u_proxima[:, -1] = self.u_proxima[:, -2] / (1 + beta * self.dy)\n</code></pre> <p>En C++:</p> <pre><code>matriz[i * n + 0] = matriz[i * n + 1] / (1 + beta * ds);\n                matriz[i * n + (n - 1)] = matriz[i * n + (n - 2)] / (1 + beta * ds);\n                matriz[0 * n + i] = matriz[1 * n + i] / (1 + beta * ds);\n                matriz[(n - 1) * n + i] = matriz[(n - 2) * n + i] / (1 + beta * ds);\n</code></pre>"},{"location":"metodos/","title":"Metodolog\u00eda","text":""},{"location":"metodos/#metodologia-numerica","title":"Metodolog\u00eda Num\u00e9rica","text":"<p>Al buscar una metodolog\u00eda num\u00e9rica para resolver la ecuaci\u00f3n de calor, se puede observar que los m\u00e9todos expl\u00edcitos, aunque son m\u00e1s f\u00e1ciles de programar, presentan limitaciones significativas  en cuanto a estabilidad y eficiencia computacional. En una dimensi\u00f3n, puede ser f\u00e1cil aumentar el n\u00famero de puntos de la malla de 100 a 1000, pero para una malla bidimensional, estos aumentos son pr\u00e1cticamente inviables.  Por esta raz\u00f3n, se opt\u00f3 por el m\u00e9todo de Crank-Nicolson. A diferencia de los m\u00e9todos expl\u00edcitos, Crank-Nicolson es incondicionalmente estable, lo que permite utilizar pasos de tiempo mayores sin perder estabilidad num\u00e9rica. Adem\u00e1s, su esquema promedio entre el tiempo actual y el siguiente mejora significativamente la precisi\u00f3n temporal en comparaci\u00f3n con otros m\u00e9todos impl\u00edcitos m\u00e1s simples. Aunque su implementaci\u00f3n es m\u00e1s compleja, el rendimiento obtenido y la calidad de los resultados justifican su elecci\u00f3n para el problema a resolver.</p>"},{"location":"metodos/#metodo-de-crank-nicolson","title":"M\u00e9todo de Crank-Nicolson","text":"<p>Este m\u00e9todo consiste en una t\u00e9cnica num\u00e9rica para resolver ecuaciones diferenciales parciales, especialmente la ecuacion de calor o ecuaci\u00f3n de difusi\u00f3n. Es un metodo semi-implicito y de segundo orden; por lo que combina la precisi\u00f3n del m\u00e9todo del punto medio y la estabilidad del m\u00e9todo implicito.  Este m\u00e9todo se basa en una promediaci\u00f3n entre el m\u00e9todo expl\u00edcito, que eval\u00faa  en el tiempo actual \\(t_n\\) y el m\u00e9todo implicito, que eval\u00faa en el siguiente tiempo \\(t_n+1\\). </p> <p>En el apartado de los codigos, se explicara a detalle los codigos realizados con el fin de comprender a totalidad c\u00f3mo funciona el m\u00e9todo de Crank-Nicolson para resolver la ecuacion de calor en 2D. </p> <p>Ventajas:</p> <p>1) Estabilidad incondicional: Es estable para cualquier tamano de paso en el tiempo, lo que permite hacer simulaciones con pasos grandes sin que el error explote.</p> <p>2) Mayor precision: Tanto el tiempo como el espacio es de segudno orden, significa que es mas preciso que los metodos de primer orden, como lo es el metodo explicito o el implicito simple.</p> <p>3) Simetria temporal: Este metodo es centrado en el tiempo, lo que lo hace ideal para problemas en donde se debe de conservar energia o simetria. </p> <p>Desventajas:</p> <p>1) Se requiere resolver un sistema lineal en cada paso: Con el metodo de Crank-Nicolson tenemos que resolver matrices en cada paso del tiempo, lo que es mucho mas costoso computacionalmente.</p> <p>2) Oscilaciones no fisicas: Si esto se aplica a problemas de condiciones inciales, puede producir oscilaciones no reales.</p> <p>3) Implementacion mas compleja: Este metodo requiere mas trabajo para programarlo, puesto que combina terminos del tiempo actual y del siguiente paso.</p>"},{"location":"metodos/#alternating-direction-implicit-adi","title":"Alternating Direction Implicit (ADI)","text":"<p>Es un m\u00e9todo que se utiliza para resolver m\u00e1s f\u00e1cilmente la ecuaci\u00f3n de calor en 2D. En lugar de resolver una ecuaci\u00f3n impl\u00edcita en dos dimensiones al mismo tiempo (lo que da lugar a una matriz muy grande), el m\u00e9todo ADI divide el paso de tiempo en dos mitades:</p> <ul> <li> <p>En la primera mitad del paso de tiempo, se utiliza el m\u00e9todo impl\u00edcito solo en la direcci\u00f3n \\(x\\), y se deja \\(y\\) expl\u00edcito.</p> </li> <li> <p>En la segunda mitad, se hace lo mismo, pero ahora \\(y\\) es impl\u00edcito y \\(x\\) expl\u00edcito.</p> </li> </ul> <p>Esto reduce el problema de 2D a varios problemas 1D, que son mucho m\u00e1s f\u00e1ciles de resolver. Cuando se utiliza ADI, en cada paso intermedio es necsario resolver muchos sistemas 1D impl\u00edcitos (uno por cada fila o columna) con forma tridiagonal.</p> <p>## Matriz Tridiagonal</p> <p>En el proceso de implementaci\u00f3n del m\u00e9todo de Crank-Nicolson y API para la resoluci\u00f3n de la ecuaci\u00f3n de calor; organuzando los terminos, la rucaci\u00f3n se convierte en una ecuaci\u00f3n matricial de la forma: \\(A\\vec{\\phi^{n+1}}=\\vec{d^n}\\), donde A es una mtriz es tridiagonal de N dimensiones, con N n\u00fameros de subdivisiones de la descretizaci\u00f3n espacial, esto se puede visualizar como:</p> <p> </p> <p>Una matriz tridiagonal es una matriz en la que solo los elementos de la diagonal principal y las dos diagonales adyacentes (la superior y la inferior) pueden tener valores distintos de cero. Este patr\u00f3n de estructura permite representar de manera eficiente operadores como el Laplaciano en una dimensi\u00f3n espacial. En el caso del esquema de Crank-Nicolson, este tipo de matriz se forma tanto en la parte impl\u00edcita como en la parte expl\u00edcita del m\u00e9todo.</p> <p>A diferencia de un sistema lineal general, cuya soluci\u00f3n mediante m\u00e9todos cl\u00e1sicos como la eliminaci\u00f3n gaussiana requiere un costo computacional de orden \\(O(N^3)\\), los sistemas tridiagonales pueden resolverse en tiempo lineal, es decir, \\(O(N)\\), utilizando el m\u00e9todo de Thomas. Este m\u00e9todo es una versi\u00f3n especializada de la eliminaci\u00f3n de Gauss que aprovecha la estructura tridiagonal para reducir el n\u00famero de operaciones necesarias. El m\u00e9todo transforma la matriz original en una matriz triangular superior mediante una etapa de eliminaci\u00f3n hacia adelante, y luego obtiene la soluci\u00f3n aplicando sustituci\u00f3n hacia atr\u00e1s.</p> <p>Al trabajar con solo tres vectores (diagonal principal, inferior y superior), se evita almacenar la matriz completa reduciendo el consumo de memoria.</p>"},{"location":"python/","title":"Solui\u00f3n en Python","text":"<p>En el presente apartado explicaremos a detalle cada linea de codigo de la resolucion de la Ecuacion de calor realizada en Python.</p> <p>Iniciamos importando las librerias, en donde numpy nos ayuda a realizar calculos numericos y el manejo de arreglos/matirces; matplotlib.pyplot, grafica y visualiza datos;  scipy.sparse.diags, permite crear matrices dispersas que ahorran memoria y son mas eficientes; scipy.sparse.linalg.spsolve, resuelve sistemas lineales que usan matrices dispersas; FuncAnimation, permite crear animaciones y Image, sirve para mostrar imagenes en entornos como Jupyter Notebook. </p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.sparse import diags\nfrom scipy.sparse.linalg import spsolve\nfrom matplotlib.animation import FuncAnimation\nfrom IPython.display import Image\n</code></pre> <p>Se define la clase principal para simular la ecuacion de calor en 2D. En donde el constructor de la clase es init y alpha es la difusividad termica, Lx, Ly son las dimensiones del dominio, Nx, Ny son las divisiones del espacio y dt, T es el paso y tiempo total de simulacion. </p> <pre><code>class SimuladorDifusionCalor2D:\n\n    def __init__(self, alpha, Lx, Ly, Nx, Ny, dt, T):\n\n        # Par\u00e1metros f\u00edsicos y de discretizaci\u00f3n espacial\n        self.alpha = alpha # Coeficiente de difusi\u00f3n t\u00e9rmica\n        self.Lx, self.Ly = Lx, Ly # Dimensiones del dominio (largo y ancho)\n        self.Nx, self.Ny = Nx, Ny # Cantidad de divisiones en las direcciones x e y\n        self.dx = Lx / Nx # Tama\u00f1o del paso espacial en x\n        self.dy = Ly / Ny # Tama\u00f1o del paso espacial en y\n</code></pre> <p>Define las propiedades fisicas y espaciales del dominio. </p> <pre><code>        self.x = np.linspace(0, Lx, Nx + 1) # Crear un array con las coordenadas x de la malla\n        self.y = np.linspace(0, Ly, Ny + 1) # Crear un array con las coordenadas y de la malla\n        # malla de coordenadas 2D\n        self.X, self.Y = np.meshgrid(self.x, self.y, indexing='ij')\n</code></pre> <p>Crea la malla espacial 2D.</p> <pre><code>        # Par\u00e1metros temporales\n        self.dt = dt # Tama\u00f1o del paso de tiempo\n        self.T = T # Tiempo total de simulaci\u00f3n\n        self.nt = int(T / dt) # N\u00famero total de pasos de tiempo\n</code></pre> <p>Configura la discretizacion temporal.</p> <pre><code>        # Par\u00e1metros usados en el m\u00e9todo ADI \n        self.parametro_x = alpha * dt / (2 * self.dx ** 2) # Par\u00e1metro de difusi\u00f3n en direcci\u00f3n x\n        self.parametro_y = alpha * dt / (2 * self.dy ** 2) # Par\u00e1metro de difusi\u00f3n en direcci\u00f3n y\n</code></pre> <p>Coeficientes del metodo ADI.</p> <pre><code>        # Construir las matrices dispersas necesarias para el m\u00e9todo ADI\n        self._construir_matrices()\n</code></pre> <p>Llama al metodo para construir las matrices tridiagonales. En donde se inicializa las matrices de temperatura y el historial para animacion.             </p> <pre><code>        # Inicializar las matrices de temperatura\n        self.u = np.zeros((Nx + 1, Ny + 1)) # Matriz de temperatura actual, inicializada a ceros\n        self.u_proxima = np.zeros_like(self.u) # Matriz para la temperatura en el siguiente paso de tiempo, inicializada de forma similar a u\n        self.historial_temperaturas = [] # Lista para almacenar el estado de la temperatura en diferentes momentos\n        self.intervalo_guardado = 10  # Guarda el estado de la temperatura cada 10 pasos de tiempo\n</code></pre> <p>Construccion de matrices tridiagonales</p> <pre><code>    # M\u00e9todo para construir las matrices dispersas \n    def _construir_matrices(self):\n\n        Nx, Ny = self.Nx, self.Ny # Obtener el n\u00famero de puntos de discretizaci\u00f3n\n        px, py = self.parametro_x, self.parametro_y # Obtener los par\u00e1metros de difusi\u00f3n\n</code></pre> <p>EL self.Ax cre matrices implicitas y el self.Bx crea mastrices explicitas para la direccion x. </p> <pre><code>        # Construir la matriz Ax para la difusi\u00f3n en x (impl\u00edcita)\n        # Es una matriz tridiagonal (diagonal principal, subdiagonal y superdiagonal)\n        self.Ax = diags([[-px] * (Nx - 2), [1 + 2 * px] * (Nx - 1), [-px] * (Nx - 2)], [-1, 0, 1], shape=(Nx-1, Nx-1))\n        # Construir la matriz Bx para la difusi\u00f3n en x (parte expl\u00edcita)\n        # Es una matriz tridiagonal\n        self.Bx = diags([[px] * (Nx - 2), [1 - 2 * px] * (Nx - 1), [px] * (Nx - 2)], [-1, 0, 1], shape=(Nx-1, Nx-1))\n</code></pre> <p>EL self.Ay cre matrices implicitas y el self.By crea mastrices explicitas para la direccion y. </p> <pre><code>        # Construir la matriz Ay para la difusi\u00f3n en y (impl\u00edcita)\n        self.Ay = diags([[-py] * (Ny - 2), [1 + 2 * py] * (Ny - 1), [-py] * (Ny - 2)], [-1, 0, 1], shape=(Ny-1, Ny-1))\n        # Construir la matriz By para la difusi\u00f3n en y (expl\u00edcita)\n        self.By = diags([[py] * (Ny - 2), [1 - 2 * py] * (Ny - 1), [py] * (Ny - 2)], [-1, 0, 1], shape=(Ny-1, Ny-1))\n</code></pre> <p>Condiciones iniciales; permite elegir entre el pulso gaussiano centrado, paraboloide invertido y la ondsa senoidal. </p> <pre><code>    # Establecer la condici\u00f3n inicial de temperatura\n    def condicion_inicial(self, tipo):\n\n        # Pulso gaussiano centrado en (0.5, 0.5)\n        if tipo == 'gauss':\n            self.u[:, :] = np.exp(-100 * ((self.X - 0.5) ** 2 + (self.Y - 0.5) ** 2))\n        # Paraboloide centrado\n        elif tipo == 'paraboloide':\n            self.u[:, :] = 10 * ((self.X - 0.5) ** 2 + (self.Y - 0.5) ** 2)\n        # Onda Senosoidal\n        elif tipo == 'senoidal':\n            self.u[:, :] = np.sin(2 * np.pi * self.X) * np.sin(2 * np.pi * self.Y)\n        # Si no funciona, lanzar error de condici\u00f3n incial no conocida\n        else:\n            raise ValueError(f\"Condici\u00f3n inicial desconocida: {tipo}\")\n</code></pre> <p>Simulacion; ejecuta la simulacion usando ADI, en donde el primer medio paso es implicito en x, el segundo medio paso es implicito en y, y por ultimo, se aplican las condiciones de frontera. </p> <pre><code>    # M\u00e9todo para ejecutar la simulaci\u00f3n\n    def simular(self, frontera):\n        # Iterar sobre el n\u00famero total de pasos de tiempo\n        for n in range(self.nt):\n            # Matriz temporal para almacenar resultados intermedios\n            u_intermedia = np.zeros_like(self.u)\n\n            # Recorremos cada fila fija (j) y resolvemos en x (columnas)\n            for j in range(1, self.Ny):\n                # Calcular el lado derecho del sistema lineal en la direcci\u00f3n x\n                rhs = self.Bx.dot(self.u[1:self.Nx, j])\n                # Resolver el sistema lineal en x\n                u_intermedia[1:self.Nx, j] = spsolve(self.Ax, rhs)\n\n            # Segundo medio paso (expl\u00edcito en x, impl\u00edcito en y)\n            # resolvemos en la direcci\u00f3n y, manteniendo x fijo\n            for i in range(1, self.Nx):\n                # Calcular el lado derecho del sistema lineal en la direcci\u00f3n y\n                rhs = self.By.dot(u_intermedia[i, 1:self.Ny])\n                # Resolver el sistema lineal en y\n                self.u_proxima[i, 1:self.Ny] = spsolve(self.Ay, rhs)\n\n            # Aplicar condiciones de frontera \n            if frontera == 'dirichlet':\n                # Condici\u00f3n de frontera de Dirichlet (temperatura fija en los bordes)\n                self.u_proxima[0, :] = 0 # Borde izquierdo\n                self.u_proxima[-1, :] = 0 # Borde derecho\n                self.u_proxima[:, 0] = 0 # Borde inferior\n                self.u_proxima[:, -1] = 0 # Borde superior\n            elif frontera == 'neumann':\n                # Condici\u00f3n de frontera de Neumann (flujo de calor cero en los bordes)\n                self.u_proxima[0, :] = self.u_proxima[1, :] # Borde izquierdo\n                self.u_proxima[-1, :] = self.u_proxima[-2, :] # Borde derecho\n                self.u_proxima[:, 0] = self.u_proxima[:, 1] # Borde inferior\n                self.u_proxima[:, -1] = self.u_proxima[:, -2] # Borde superior\n            elif frontera == 'robin':\n                # Condici\u00f3n de frontera de Robin \n                beta = 3.0 # Coeficiente de convecci\u00f3n \n                self.u_proxima[0, :] = self.u_proxima[1, :] / (1 + beta * self.dx) # Borde izquierdo\n                self.u_proxima[-1, :] = self.u_proxima[-2, :] / (1 + beta * self.dx) # Borde derecho\n                self.u_proxima[:, 0] = self.u_proxima[:, 1] / (1 + beta * self.dy) # Borde inferior\n                self.u_proxima[:, -1] = self.u_proxima[:, -2] / (1 + beta * self.dy) # Borde superior\n            # Lanzar un error si el tipo de frontera no es v\u00e1lido\n            else:\n                raise ValueError(f\"Condici\u00f3n de frontera no v\u00e1lida: {frontera}\")\n</code></pre> <p>Actualiza la matriz de temperatura para el siguiente paso de tiempo.</p> <pre><code>            self.u[:, :] = self.u_proxima[:, :]\n</code></pre> <p>Guarda el estado actual periodicamente.</p> <pre><code>            if n % self.intervalo_guardado == 0:\n                self.historial_temperaturas.append(self.u.copy()) #.copy() para guardar una copia y no una referencia\n</code></pre> <p>Muestra el mapa de calor en el estado final de la simulaci\u00f3n.</p> <pre><code>    def mostrar_estado_final(self):\n        plt.figure(figsize=(7, 6))\n        mapa = plt.contourf(self.X, self.Y, self.historial_temperaturas[-1], 20, cmap='hot') # Crea un gr\u00e1fico de mapa de calor del estado final de la temperatura\n        plt.colorbar(mapa)  # Agrega barra de color para indicar los valores de temperatura\n        plt.title(f\"Mapa de Calor\")\n        plt.xlabel(\"x\")\n        plt.ylabel(\"y\")\n        plt.tight_layout()\n        plt.show()\n</code></pre> <p>Crea una animacion de la evolucion de la temperatura. </p> <pre><code>    def animar(self, intervalo_ms=400, fps=10):\n\n        fig, ax = plt.subplots(figsize=(7, 6))\n        cont = ax.contourf(self.X, self.Y, self.historial_temperaturas[0], 20, cmap='hot')\n        fig.colorbar(cont, ax=ax)\n</code></pre> <p>Funci\u00f3n que se llama en cada frame de la animaci\u00f3n.</p> <pre><code>        def update(frame):\n            # Limpiar los ejes para dibujar el nuevo frame\n            ax.clear()\n            # Crear el gr\u00e1fico de contorno para el estado de temperatura del frame actual\n            cont = ax.contourf(self.X, self.Y, self.historial_temperaturas[frame], 20, cmap='hot')\n            # Actualizar el t\u00edtulo con el tiempo actual de la simulaci\u00f3n\n            ax.set_title(f\"t = {frame * self.intervalo_guardado * self.dt:.3f} s\")\n            ax.set_xlabel(\"x\")\n            ax.set_ylabel(\"y\")\n</code></pre> <p>Crea el objeto FuncAnimation.</p> <pre><code>        anim = FuncAnimation(fig, update, frames=len(self.historial_temperaturas), interval=intervalo_ms, blit=False)\n        # Cerrar la figura para evitar que se muestre como un gr\u00e1fico est\u00e1tico\n        plt.close(fig)\n        # Mostrar la animaci\u00f3n como un video HTML \n        display(HTML(anim.to_jshtml()))\n</code></pre> <p>Llama la clase simulador y establecer las condiciones iniciales y de frontera. En donde sim crea el objeto de simulacion, sim.condicion_inicial('paraboloide')  establece la condicion inicial tipo paraboloide y sim.simular(frontera='neumann') corre la simulacion con condiciones de Neumann.</p> <pre><code># Caso: Condicion inicial de Paraboloide y condici\u00f3n de frontera de Neumann\nsim = SimuladorDifusionCalor2D(alpha=1.0, Lx=1.0, Ly=1.0, Nx=40, Ny=40, dt=0.0005, T=0.1)\nsim.condicion_inicial('paraboloide')  \nsim.simular(frontera='neumann')\n</code></pre> <p>Mapa de calor para condici\u00f3n inicial de Paraboloide y condici\u00f3n de frontera de Neumann; muestra el mapa de calor de la ultima distribucion de la temperatura. </p> <pre><code>sim.mostrar_estado_final()\n</code></pre> <p>Animaci\u00f3n para condici\u00f3n inicial de Paraboloide y condici\u00f3n de frontera de Neumann.</p> <pre><code>sim.animar()\n</code></pre> <p>Caso: Condicion inicial de Paraboloide y condici\u00f3n de frontera de Neumann.</p> <pre><code>sim_gaussiano = SimuladorDifusionCalor2D(alpha=1.0, Lx=1.0, Ly=1.0, Nx=40, Ny=40, dt=0.0005, T=0.1)\nsim_gaussiano.condicion_inicial('gauss')  \nsim_gaussiano.simular(frontera='dirichlet')\n</code></pre> <p>Mapa de calor para condici\u00f3n inicial de Gauss y condici\u00f3n de frontera de Dirichlet.</p> <pre><code>sim_gaussiano.mostrar_estado_final()\n</code></pre> <p>Animaci\u00f3n para condici\u00f3n inicial de Gauss y condici\u00f3n de frontera de Dirichlet.</p> <pre><code>sim_gaussiano.animar()\n</code></pre> <p>Caso: Condicion inicial de onda senoidal y condici\u00f3n de frontera de Dirichlet.</p> <pre><code>sim_senoidal = SimuladorDifusionCalor2D(alpha=1.0, Lx=1.0, Ly=1.0, Nx=40, Ny=40, dt=0.0005, T=0.1)\nsim_senoidal.condicion_inicial('senoidal')  \nsim_senoidal.simular(frontera='robin')\n</code></pre> <p>Mapa de calor para condici\u00f3n inicial de  y condici\u00f3n de frontera de Dirichlet.</p> <pre><code>sim_senoidal.mostrar_estado_final()\n</code></pre> <p>Animaci\u00f3n para condici\u00f3n inicial de  y condici\u00f3n de frontera de Dirichlet.</p> <pre><code>sim_senoidal.animar()\n</code></pre>"},{"location":"resultados/","title":"An\u00e1lisis de resultados","text":"<p>Los resultados que se presentan en este apartado corresponden a la simulaci\u00f3n num\u00e9rica de la ecuaci\u00f3n de calor en dos dimensiones resuelta mediante el m\u00e9todo de Crank-Nicolson-ADI. Las gr\u00e1ficas muestran la evoluci\u00f3n del perfil de temperatura en la malla, partiendo de distintas condiciones iniciales (distribuciones gaussianas, paraboloides u ondas senoidales) y bajo diferentes tipos de condiciones de frontera (Dirichlet, Neumann o Robin). Estas simulaciones permiten observar c\u00f3mo el calor se distribuye y disipa a lo largo del dominio con el paso del tiempo.</p>"},{"location":"resultados/#grafico-y-simulacion-de-la-campana-gaussiana-centrada-con-condicion-de-frontera-de-dirichlet","title":"Grafico y simulacion de la campana Gaussiana centrada con condicion de frontera de Dirichlet.","text":"<p>En base a lo observado la solucion de dichos graficos es simetrica, lo cual se espera por la simetria del pulso y la geometria cuadrada. La temperatura decrece hacia los bordes, puesto que al tener la condicion inicial de Dirichlet, la temperatura es fija en cero. Hay presencia de contornos concentricos desde el centro hacia afuera, indicando asi una difusion isotropica, es decir, una difusion igual en todas las direcciones.  El comportamiento del grafico y la simulacion es correcto, puesto que la difusion se comporta como predice la ecuacion de calor, es decir, que se presenta una distribucion de temperatura uniforme, no hay oscilaciones artificiales ni errores numericos y se cumplen las condiciones de frontera establecidas. </p>"},{"location":"resultados/#grafico-y-simulacion-de-un-paraboloide-centrado-con-condicion-de-frontera-de-neumann","title":"Grafico y simulacion de un paraboloide centrado con condicion de frontera de Neumann.","text":"<p>Al tener dichas condiciones iniciales y de frontera, las mismas hacen que se refleje el calor, lo que provoca que no se pierda energia termica por las fronteras. Se observa una acumulacion de calor en las esquinas, lo que es caracteristico cuando se inicia con un minimo central y se impide que el calor escape. Ademas, el gradiente de temperatura apunta hacia el centro, lo cual es consistente cuando se presenta un paraboloide negativo.  Por lo que los resultados de este grafico y simulacion son los esperados, ya que se observa que no hay perdida de calor por los bordes, que la condicion de Neumann esta bien aplicada y que respeta las simetrias y propiedades del metodo utilizado. </p>"},{"location":"resultados/#grafico-y-simulacion-de-una-onda-senosoidal-con-condicion-de-frontera-de-robin","title":"Grafico y simulacion de una onda senosoidal con condicion de frontera de Robin.","text":"<p>Se logra observar que el patron senoidal se conserva, lo que sugiere una posible solucion estacionaria o un estado inicial muy cercano al equilibrio. EL grafico y la simulacion muestra dos maximos positivos y dos minimos negativos, lo que es correcto cuando se trabaja con una onda con 2 ciclos en cada eje. Los valores son muy pequenos, lo que indica que el sistema esta cerrado cerca del equilibrio termico o con condiciones suaves. La condicion de frontera de Robin, permite un intercambio parcial de calor en los bordes, lo que es coherente con la conservacion parcial del perfil de onda, ademas, en soluciones senoidales estacionarias es comun ver un patron simetrico y balanceado positivo-negativo, lo cual, se logra apreciar en el grafico y la simulacion. </p>"}]}