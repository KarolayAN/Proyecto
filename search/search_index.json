{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Ecuaci\u00f3n de Calor en 2D","text":"<p>Universidad de Costa Rica</p> <p>Proyecto Final de F\u00edsica Computacional</p> <p>I Semestre 2025</p> <p>Nombre de los estudiantes:</p> <p>Alba Sofia Rojas Doza (C36873)</p> <p>Oscar Alvarez Poveda (C003949) </p> <p>Ricardo Jose Suarez Sancho (C17810)</p> <p>Karolay Alvarado Navarro (C20359)</p> <p>Julio 2025</p>"},{"location":"#introduccion","title":"Introduccion","text":"<p>La ecuaci\u00f3n de calor en dos dimensiones es una ecuaci\u00f3n en derivadas parciales de segundo orden que describe la evoluci\u00f3n temporal de la temperatura en una regi\u00f3n del espacio bajo condiciones f\u00edsicas ideales. Esta ecuaci\u00f3n toma la forma:</p> <p>\\(\\frac{\\partial u}{\\partial t} = c^2 \\left( \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} \\right)\\)</p> <p>en donde \\(u(x,y,t)\\) representa la temperatura en la posicion \\((x,y)\\) en el tiempo \\(t\\), \\(c\\) es una constante que depende del material y \\(\\Delta^2\\) es el operador Laplaciano, que en dos dimensiones que viene de la expresi\u00f3n:</p> <p>\\(\\Delta^2u = \\left( \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} \\right)\\)</p> <p>Este modelo es v\u00e1lido bajo condiciones ideales, como materiales homog\u00e9neos, sin fuentes de calor internas y con propiedades t\u00e9rmicas constantes. La ecuaci\u00f3n se utiliza para modelar la transferencia de calor en placas, l\u00e1minas y superficies, siendo fundamental en campos como la ingenier\u00eda, la geof\u00edsica, la medicina y la ciencia de materiales.</p> <p>Adem\u00e1s,  permite analizar el comportamiento t\u00e9rmico de sistemas bidimensionales sujetos a distintas condiciones iniciales y de frontera.</p> <p>En el desarrollo del proyecto, se resolvera dicha ecuaci\u00f3n tanto en Python como en C++, aplicando as\u00ed pr\u00e1cticas estudiadas en el curso, como el uso apropiado de recursos de memoria, prinicipios de programacion orientada a objetos, paralelismo en memoria compartida, la documentacion y control de versiones con Git. </p> <p>Asimismo, debemos de experimentar con diferentes condiciones inciales y de frontera, y visualizar la evolucion temporal de la temperatura mediante mapas de colores. </p>"},{"location":"bibliografia/","title":"Bibligraf\u00eda","text":""},{"location":"bibliografia/#referencias-bibliograficas","title":"Referencias Bibliogr\u00e1ficas","text":"<p>[] Morton, K &amp; Mayers, D. Numerical Solution of Partial Differential Equations Cambridge University Pres. 2nd Edition (2005).\\ [] M. Newman, Computational Physics, CreateSpace, DC, USA, 1st Edition (2013) .\\ [] Recktenwald, G. Finite-Difference Approximations to the Heat Equation. Mechanical Engineering. (2004).\\ [] Su, V. Finite Difference Methods Applied to the Heat Equation in 1D and 2D. (2013).</p>"},{"location":"c%2B%2B/","title":"Soluci\u00f3n en C++","text":"<p>El presente c\u00f3digo en C++ tiene como objetivo resolver la ecuaci\u00f3n de calor en dos dimensiones. Para resolverla de forma eficiente, el c\u00f3digo implementa el m\u00e9todo Crank\u2013Nicolson con Alternating Direction Implicit (ADI). Este m\u00e9todo permite dividir cada paso temporal en dos subpasos alternados en direcci\u00f3n horizontal y vertical, facilitando la resoluci\u00f3n de matrices tridiagonales mediante el eficiente m\u00e9todo de Thomas.</p> <p>Adem\u00e1s, se integran t\u00e9cnicas de paralelismo de memoria compartida usando OpenMP, lo que permite reducir significativamente los tiempos de c\u00e1lculo. El c\u00f3digo est\u00e1 dise\u00f1ado para permitir la elecci\u00f3n entre distintas condiciones iniciales</p> <p>La siguiente funci\u00f3n crea una matriz representada como un vector de 1D:\\ Se utilizaron las siguientes bibliotecas:</p> <ul> <li><code>&lt;iostream&gt;</code>: Para poder utilizar inputs y outputs con std.</li> <li><code>&lt;cmath&gt;</code>: Para poder agregar funciones matem\u00e1ticas</li> <li><code>&lt;vector&gt;</code>: Para poder usar std::vector</li> <li><code>&lt;omp.h&gt;</code>: Para paralelizar con OpenMP</li> </ul> <pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n#include &lt;vector&gt;\n#include &lt;omp.h&gt;\n</code></pre> <p>Funci\u00f3n que crea una matriz llena de ceros, y la almacena en 1 vector de 1D\\ <code>n</code> N\u00famero de filas.\\ <code>m</code> N\u00famero de columnas.\\ <code>return std::vector&lt;double&gt;</code> Se retorna un vector <code>nxm</code> que contiene los arreglos de ceros</p> <pre><code>std::vector&lt;double&gt; crearMatrizCeros(int n, int m) {\n    return std::vector&lt;double&gt;(n * m, 0.0);\n}\n</code></pre> <p>Funci\u00f3n que imprime la matriz creada anteriormente\\ Se imprime en la consola la matriz nxn contenida en un vector de 1D. Para esto se utilzan 3 cifras decimales por cada entrada de la matriz.\\ <code>matriz</code> Vector que contiene la matriz creada previamente de forma lineal.\\ <code>n</code> N\u00famero de filas de la matriz.</p> <pre><code>void imprimirMatriz(const std::vector&lt;double&gt;&amp; matriz, int n) {\n    for (int i = 0; i &lt; n; ++i) {\n        for (int j = 0; j &lt; n; ++j) {\n            printf(\"%.3f \", matriz[i * n + j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}\n</code></pre> <p>Funci\u00f3n que multiplica la matriz anteior por un vector.\\ Se hace una multiplicaci\u00f3n entre la matriz guardada en el vector 1D y un vector de las mismas dimensiones.  El resultado obtenido de la multiplicaci\u00f3n sobreescribe el vector original utilizado.\\ <code>matriz</code> Vector que contiene la matriz creada previamente de forma lineal.\\ <code>vec</code> Vector por el cual se multiplica la matriz, y en el cual se guardan los resultados de la multiplicaci\u00f3n.\\ <code>n</code> N\u00famero de filas de la matriz.\\</p> <pre><code>void multiplicarMatrizVector(const std::vector&lt;double&gt;&amp; matriz, std::vector&lt;double&gt;&amp; vec, int n) {\n    std::vector&lt;double&gt; temp(n, 0.0);\n    for (int i = 0; i &lt; n; ++i)\n        for (int j = 0; j &lt; n; ++j)\n            temp[i] += matriz[i * n + j] * vec[j];\n    vec = temp; \n}\n</code></pre> <p>Funci\u00f3n que resuelve el sistema tridiagonal usando el m\u00e9todo de Thomas\\ Se resuelve el sistema de ecuaciones lineales obtenido, el cual incluye una matriz tridiagonal, utilizando el m\u00e9todo de Thomas. La soluci\u00f3n se almacena en el vector u, sobrescribiendo as\u00ed su contenido.\\ <code>T</code> Matriz tridiagonal resuelta por medio del m\u00e9todo de Thomas, y almacenada de forma 1D.\\ <code>u</code> Vector con los t\u00e9rminos independientes del sistema tridiagonal.\\ <code>n</code> Dimensi\u00f3n de la matriz.\\ El resultado final se guarda en el vector <code>u</code>.</p> <pre><code>void resolverTridiagonal(const std::vector&lt;double&gt;&amp; T, std::vector&lt;double&gt;&amp; u, int n) {\n    std::vector&lt;double&gt; a(n, 0.0), b(n, 0.0), c(n, 0.0), x(n, 0.0);\n    for (int i = 0; i &lt; n; i++) b[i] = T[i * n + i];\n    for (int i = 0; i &lt; n-1; i++) {\n        a[i+1] = T[(i+1) * n + i];\n        c[i] = T[i * n + (i + 1)];\n    }\n    c[0] /= b[0];\n    x[0] = u[0] / b[0];\n    for (int i = 1; i &lt; n; i++) {\n        double m = b[i] - a[i] * c[i-1];\n        c[i] /= m;\n        x[i] = (u[i] - a[i] * x[i-1]) / m;\n    }\n    for (int i = n - 2; i &gt;= 0; i--)\n        x[i] -= c[i] * x[i + 1];\n    u = x;\n}\n</code></pre> <p>Funci\u00f3n que crea una matriz tridiagonal implicita\\  Se crea una matriz tridiagonal impl\u00edcita con valores 1+2r en la diagonal principal y -r en las otras dos diagonales.\\  <code>n</code> Dimensi\u00f3n de la matriz.\\  <code>r</code> Valor de la variable discretizada que relaciona la parte espacial y temporal de la ecuaci\u00f3n diferencial.\\ <code>return Laplaciano</code> Se retorna un Laplaciano tridiagonal impl\u00edcito nxn.</p> <pre><code>std::vector&lt;double&gt; crearLaplacianoImplicito(int n, double r) {\n    std::vector&lt;double&gt; Laplaciano(n * n, 0.0);\n    for (int i = 0; i &lt; n; ++i) {\n        if (i == 0 || i == n - 1) {\n            Laplaciano[i * n + i] = 1.0;\n        } else {\n            Laplaciano[i * n + (i - 1)] = -r;\n            Laplaciano[i * n + i] = 1 + 2 * r;\n            Laplaciano[i * n + (i + 1)] = -r;\n        }\n    }\n    return Laplaciano;\n}\n</code></pre> <p>Funci\u00f3n que crea una matriz tridiagonal explicita\\ Se crea una matriz tridiagonal expl\u00edcita con valores 1-2r en la diagonal principal y r en las otras dos diagonales.\\ <code>n</code> Dimensi\u00f3n de la matriz.\\ <code>r</code> Valor de la variable discretizada que relaciona la parte espacial y temporal de la ecuaci\u00f3n diferencial.\\ <code>return Laplaciano</code> Se retorna un Laplaciano tridiagonal expl\u00edcito nxn.</p> <pre><code>std::vector&lt;double&gt; crearLaplacianoExplicito(int n, double r) {\n    std::vector&lt;double&gt; Laplaciano(n * n, 0.0);\n    for (int i = 0; i &lt; n; ++i) {\n        if (i == 0 || i == n - 1) {\n            Laplaciano[i * n + i] = 1;\n        } else {\n            Laplaciano[i * n + (i - 1)] = r;\n            Laplaciano[i * n + i] = 1 - 2 * r;\n            Laplaciano[i * n + (i + 1)] = r;\n        }\n    }\n    return  Laplaciano;\n}\n</code></pre> <p>Funci\u00f3n que calcula el m\u00e9todo de Crank Nicholson con Alternating Direction Implicit (ADI)\\ La funci\u00f3n resuelve la ecuaci\u00f3n de calor en 2D dividiendo la parte temporal de problema en 2 subpasos: Una parte para la direcci\u00f3n y y otra para la direcci\u00f3n x. Esto facilita poder utilizar el m\u00e9todo de Crank Nicholson al reducirlo con matrices tridiagonales. Adem\u00e1s en cada subpaso se calcula la multiplicaci\u00f3n de de matrices y la resoluci\u00f3n de la matriz tridiagonal por medio del m\u00e9todo de Thomas.\\ Para la parte de la paralelizaci\u00f3n se utiliz\u00f3 estrat\u00e9gicamente en los bucles for que involucran filas y columnas  de la malla, ya que al agregarlo en dichos <code>for</code>, la velocidad del c\u00f3digo mejora considerablemente.\\ <code>matriz</code> Matriz almacenada como un vector 1D.\\ <code>n</code> N\u00famero de puntos a utilizar\\ <code>r</code> Valor de la variable discretizada que relaciona la parte espacial y temporal de la ecuaci\u00f3n diferencial.\\ <code>pasos</code> N\u00famero de pasos a utilizar.\\ <code>bordeIzq</code> Valor de frontera en el borde izquierdo.\\ <code>bordeDer</code> Valor de frontera en el borde derecho.\\ <code>bordeInf</code> Valor de frontera del borde inferior.\\ <code>bordeSup</code> Valor de frontera del borde superior.</p> <pre><code>void CN_2D_ADI_Advance(std::vector&lt;double&gt;&amp; matriz, int n, double r, int pasos,\n                       double bordeIzq, double bordeDer, double bordeInf, double bordeSup) {\n\n    r = r / 2.0;\n    std::vector&lt;double&gt; S = crearLaplacianoExplicito(n, r);\n    std::vector&lt;double&gt; T = crearLaplacianoImplicito(n, r);\n    std::vector&lt;double&gt; temp(n * n, 0.0);\n    std::vector&lt;double&gt; fila(n);\n    std::vector&lt;double&gt; columna(n);\n\n    for (int t = 0; t &lt; pasos; ++t) {\n\n        # pragma omp parallel for\n        for (int i = 0; i &lt; n; ++i) {\n          std::vector&lt;double&gt; fila(n);\n          for (int j = 0; j &lt; n; ++j)\n            fila[j] = matriz[i * n +j];\n          multiplicarMatrizVector(S, fila, n);\n          for (int j = 0; j &lt; n; ++j)\n            matriz[i * n +j] = fila[j];\n        }\n\n\n        # pragma omp parallel for\n        for (int j = 0; j &lt; n; ++j) {\n            std::vector&lt;double&gt; columna(n);\n            for (int i = 0; i &lt; n; ++i)\n                columna[i] = matriz[i * n + j];\n            resolverTridiagonal(T, columna, n);\n            for (int i = 0; i &lt; n; ++i)\n                matriz[i * n + j] = columna[i];\n        }\n\n\n\n        # pragma omp parallel for\n        for (int j = 0; j &lt; n; ++j) {\n          std::vector&lt;double&gt; columna(n);\n          for (int i = 0; i &lt; n; ++i)\n            columna[i] = matriz[i * n +j];\n          multiplicarMatrizVector(S, columna, n);\n          for (int i = 0; i &lt; n; ++i)\n            matriz[i * n + j] = columna[i];\n        }\n\n\n\n        # pragma omp parallel for\n        for (int i = 0; i &lt; n; ++i) {\n            std::vector&lt;double&gt; fila(n);\n            for (int j = 0; j &lt; n; ++j)\n                fila[j] = matriz[i * n +j];\n            resolverTridiagonal(T, fila, n);\n            for (int j = 0; j &lt; n; ++j)\n                matriz[i * n + j] = fila[j];\n        }\n    }\n}\n</code></pre> <p>Clase <code>solucion_ecuacion_calor</code> Consiste en los procesos necesarios para resolver el problema. En esta se configuran las condiciones iniciales y de frontera, adem\u00e1s de que se crean las funciones con las cu\u00e1les se calcula la soluci\u00f3n del  problema.</p> <p>Atributos - <code>n, dt, t, alpha2, ds, r, pasos</code>: par\u00e1metros num\u00e9ricos. - <code>opcion</code>: condici\u00f3n inicial seleccionada. - <code>condicion_frontera</code>: tipo de borde (1: Dirichlet, 2: Neumann, 3: Robin). - <code>matriz</code>: contiene los valores de temperatura.</p> <p>Funciones p\u00fablicas</p> <pre><code>solucion_ecuacion_calor(int n, double dt, double t, double alpha2 = 1.0);\nvoid opcion_escogida(int opcion_variable);\nvoid condicion_front_escog(int condicion);\nvoid aplicar_condicion_inicial();\nvoid evaluar_condicion_frontera();\nvoid resolver();\nvoid imprimir();\n</code></pre> <p>Funciones privadas</p> <pre><code>double evaluar_condicion_ini(double x, double y);\n</code></pre> <p>Evalu\u00e1 la condici\u00f3n inicial dependiendo de la opci\u00f3n escogida.</p> <p>Funci\u00f3n main\\ Inicializa todo el c\u00f3digo para resolver la ecuaci\u00f3n de calor en 2-D. Para esto el usuario primero debe de escoger una de las tres condiciones iniciales y una de las tres condiciones de frontera. El programa eval\u00faa dicha condici\u00f3n incial usando el m\u00e9todo de Crank Nicholson y la reducci\u00f3n de la matriz tridiagonal con el m\u00e9todo de Thomas, y luego imprime el resultado obtenido.\\ <code>return 0</code> si el programa se ejecuta sin ning\u00fan problema, y 1 si la opci\u00f3n elegida no era v\u00e1lida.</p> <pre><code>int main() {\n    int ns = 50;\n    double dt = 0.0005, t = 0.1;\n\n    int opcion_cond_ini;\n    std::cout &lt;&lt; \"Escoja una de las siguientes condiciones iniciales al ingresar el n\u00famero correspondiente: \\n\";\n    std::cout &lt;&lt; \" 1. Pulso Gaussiano centrado \\n2. Paraboloide centrado \\n3. Onda senoidal suave \\n\";\n    std::cin &gt;&gt; opcion_cond_ini;\n\n    int condicion_frontera;\n    std::cout &lt;&lt; \"Escoja una de las siguientes condiciones de frontera al ingresar el n\u00famero correspondiente: \\n\";\n    std::cout &lt;&lt; \" 1. Dirichlet \\n2. Neuman \\n3. Robin \\n\";\n    std::cin &gt;&gt; condicion_frontera;\n\n    if (opcion_cond_ini &lt; 1 || opcion_cond_ini &gt; 3) {\n        std::cerr &lt;&lt; \"La opci\u00f3n elegida no es v\u00e1lida. \\n\";\n        return 1;\n    }\n\n    // Se crea el constructor y se usa para llamar las funciones.\n    solucion_ecuacion_calor constructor(ns, dt, t);\n    constructor.opcion_escogida(opcion_cond_ini);\n    constructor.condicion_front_escog(condicion_frontera);\n    constructor.aplicar_condicion_inicial();\n    constructor.resolver();\n    constructor.imprimir();\n\n    return 0;\n}\n</code></pre>"},{"location":"condiciones/","title":"Condiciones","text":""},{"location":"condiciones/#condiciones-iniciales","title":"Condiciones Iniciales","text":"<p>En la ecuacion de calor en 2D, las condiciones inciales definen como esta distribuida la temperatura en todo el dominio espacial en un tiempo inicial. Las condiciones inciales y de frontera son esenciales porque determinan completamente la evolucion temporal de la temperatura.  Las condiciones iniciales que se utilizaron para la resolucion de la ecuacion de calor en 2D son: </p> <p>1) Campana Gaussiana Centrada:</p> <pre><code>u[:, :] = np.exp(-100 * ((X - 0.5)**2 + (Y - 0.5)**2))\n</code></pre> <p>Esta condicion simula una fuente de calor muy localizada, la temperatura es mas alta en el centro y disminuye rapidamente hacia los bordes. EL numero 100 en el exponente controla la concentracion de calor. Por lo que la campana Gaussiana centrada simula un calor concentrado, el cual es ideal para estudiar como se difunde el calor desde un punto. </p> <p>2) Paraboloide Centrado:</p> <pre><code>u[:, :] = 10 * ((X - 0.5)**2 + (Y - 0.5)**2)\n</code></pre> <p>En esta condicion inicial, el centro esta mas frio y la temperatura aumenta hacia los bordes, como si las paredes externas calentaran la placa. El 10 es un factor de escala que controla que tan caliente estan los bordes. EL Paraboloide centrado es bueno para estudiar el flujo del calor del exterior hacia el centro. Cabe resaltar que esta condicion inicial es simetrica radialmente. </p> <p>3) Onda Senosoidal:</p> <pre><code>u[:, :] = np.sin(2 * np.pi * X) * np.sin(2 * np.pi * Y)\n</code></pre> <p>La onda Senoidal simula el patron oscilante de calor; en donde la temperatura del dominio subiera y bajara de forma periodica. Esta condicion representa una superposicion de modos termicos y es muy util para ver como se disipan modos oscilatorios de calor en el tiempo. </p>"},{"location":"condiciones/#condiciones-de-frontera","title":"Condiciones de Frontera","text":"<p>Al resolver la ecuacion de calor en 2D, se debe de decirle al programa que es lo que pasa con los bordes de la placa, y esas son las condiciones de frontera. A continuacion, se explicaran las condiciones de frontera que se utilizaron para resolver dicha ecuacion: </p> <p>1) Dirichlet:</p> <p>Dirichlet simula una placa conectada a un material o liquido que absorbe todo el calor que llega, los bordes del dominio estan en contacto con reservorios termicos que los mantienenm a una temperatura fija. Esta condicion de frontera es muy estable y comun en simulaciones.</p> <pre><code>u_proxima[0, :] = 0; u_proxima[-1, :] = 0; u_proxima[:, 0] = 0; u_proxima[:, -1] = 0\n</code></pre> <p>2) Neumann:</p> <p>Neumann simula que los bordes estan aislados termicamente, el calor no puede salir ni entrar por los bordes y no hay flujo de calor a traves de los bordes. Esto implica que no se conoce la temperatura en la frontera, sino el flujo de calor a trav\u00e9s de ella. En este caso, lo que se fija es la tasa de variaci\u00f3n de la temperatura en direcci\u00f3n perpendicular al borde del dominio. </p> <pre><code>#u_proxima[0, :] = u_proxima[1, :]\n#u_proxima[-1, :] = u_proxima[-2, :]\n#u_proxima[:, 0] = u_proxima[:, 1]\n#u_proxima[:, -1] = u_proxima[:, -2]\n</code></pre> <p>3) Robin:</p> <p>Robin es una condici\u00f3n mixta de Neumann y Dirichlet que modela un intercambio de calor con el ambiente exterior. El parametro beta es el coeficiente de conveccion, por lo que si beta es grande, se pierde calor mas rapido y si beta es peque\u00f1o, se pierde calor lentamente. Se establece una relaci\u00f3n entre la temperatura en la frontera y su derivada normal.</p> <pre><code>beta = 3.0 # Se puede modificar el valor  (Coeficiente de transferencia de calor en fronteras [W/m\u00b2K])\nu_proxima[0, :] = u_proxima[1, :] / (1 + beta * dx)\nu_proxima[-1, :] = u_proxima[-2, :] / (1 + beta * dx)\nu_proxima[:, 0] = u_proxima[:, 1] / (1 + beta * dy)\nu_proxima[:, -1] = u_proxima[:, -2] / (1 + beta * dy)\n</code></pre>"},{"location":"metodos/","title":"Metodolog\u00eda","text":""},{"location":"metodos/#metodologia-numerica","title":"Metodolog\u00eda Num\u00e9rica","text":"<p>Al buscar una metodolog\u00eda num\u00e9rica para resolver la ecuaci\u00f3n de calor, se puede observar que los m\u00e9todos expl\u00edcitos, aunque son m\u00e1s f\u00e1ciles de programar, presentan limitaciones significativas  en cuanto a estabilidad y eficiencia computacional. En una dimensi\u00f3n, puede ser f\u00e1cil aumentar el n\u00famero de puntos de la malla de 100 a 1000, pero para una malla bidimensional, estos aumentos son pr\u00e1cticamente inviables.  Por esta raz\u00f3n, se opt\u00f3 por el m\u00e9todo de Crank-Nicolson. A diferencia de los m\u00e9todos expl\u00edcitos, Crank-Nicolson es incondicionalmente estable, lo que permite utilizar pasos de tiempo mayores sin perder estabilidad num\u00e9rica. Adem\u00e1s, su esquema promedio entre el tiempo actual y el siguiente mejora significativamente la precisi\u00f3n temporal en comparaci\u00f3n con otros m\u00e9todos impl\u00edcitos m\u00e1s simples. Aunque su implementaci\u00f3n es m\u00e1s compleja, el rendimiento obtenido y la calidad de los resultados justifican su elecci\u00f3n para el problema a resolver.</p>"},{"location":"metodos/#metodo-de-crank-nicolson","title":"M\u00e9todo de Crank-Nicolson","text":"<p>Este m\u00e9todo consiste en una t\u00e9cnica num\u00e9rica para resolver ecuaciones diferenciales parciales, especialmente la ecuacion de calor o ecuaci\u00f3n de difusi\u00f3n. Es un metodo semi-implicito y de segundo orden; por lo que combina la precisi\u00f3n del m\u00e9todo del punto medio y la estabilidad del m\u00e9todo implicito.  En s\u00edntesis, este m\u00e9todo se basa en una promediaci\u00f3n entre el m\u00e9todo expl\u00edcito, que eval\u00faa  en el tiempo actual \\(t_n\\) y el m\u00e9todo implicito, que eval\u00faa en el siguiente tiempo \\(t_n+1\\). \\ En el apartado de los codigos, se explicara a detalle los codigos realizados con el fin de comprender a totalidad c\u00f3mo funciona el m\u00e9todo de Crank-Nicolson para resolver la ecuacion de calor en 2D. </p> <p>Ventajas:</p> <p>1) Estabilidad incondicional: Es estable para cualquier tamano de paso en el tiempo, lo que permite hacer simulaciones con pasos grandes sin que el error explote.\\ 2) Mayor precision: Tanto el tiempo como el espacio es de segudno orden, significa que es mas preciso que los metodos de primer orden, como lo es el metodo explicito o el implicito simple.\\ 3) Simetria temporal: Este metodo es centrado en el tiempo, lo que lo hace ideal para problemas en donde se debe de conservar energia o simetria. </p> <p>Desventajas:</p> <p>1) Se requiere resolver un sistema lineal en cada paso: Con el metodo de Crank-Nicolson tenemos que resolver matrices en cada paso del tiempo, lo que es mucho mas costoso computacionalmente.\\ 2) Oscilaciones no fisicas: Si esto se aplica a problemas de condiciones inciales, puede producir oscilaciones no reales.\\ 3) Implementacion mas compleja: Este metodo requiere mas trabajo para programarlo, puesto que combina terminos del tiempo actual y del siguiente paso.</p>"},{"location":"metodos/#alternating-direction-implicit-adi","title":"Alternating Direction Implicit (ADI)","text":"<p>Es un m\u00e9todo que se utiliza para resolver m\u00e1s f\u00e1cilmente la ecuaci\u00f3n de calor en 2D. En lugar de resolver una ecuaci\u00f3n impl\u00edcita en dos dimensiones al mismo tiempo (lo que da lugar a una matriz muy grande), el m\u00e9todo ADI divide el paso de tiempo en dos mitades: * En la primera mitad del paso de tiempo, se utiliza el m\u00e9todo impl\u00edcito solo en la direcci\u00f3n \\(x\\), y se deja \\(y\\) expl\u00edcito. * En la segunda mitad, se hace lo mismo, pero ahora \\(y\\) es impl\u00edcito y \\(x\\) expl\u00edcito.</p> <p>Esto reduce el problema de 2D a varios problemas 1D, que son mucho m\u00e1s f\u00e1ciles de resolver. Cuando se utiliza ADI, en cada paso intermedio es necsario resolver muchos sistemas 1D impl\u00edcitos (uno por cada fila o columna) con forma tridiagonal.</p> <p>## Matriz Tridiagonal  En el proceso de implementaci\u00f3n del m\u00e9todo de Crank-Nicolson y API para la resoluci\u00f3n de la ecuaci\u00f3n de calor; organuzando los terminos, la rucaci\u00f3n se convierte en una ecuaci\u00f3n matricial de la forma: \\(A\\vec{\\phi^{n+1}}=\\vec{d^n}\\), donde A es una mtriz es tridiagonal de N dimensiones, con N n\u00fameros de subdivisiones de la descretizaci\u00f3n espacial.   </p> <p>Una matriz tridiagonal es una matriz en la que solo los elementos de la diagonal principal y las dos diagonales adyacentes (la superior y la inferior) pueden tener valores distintos de cero. Este patr\u00f3n de estructura permite representar de manera eficiente operadores como el Laplaciano en una dimensi\u00f3n espacial. En el caso del esquema de Crank-Nicolson, este tipo de matriz se forma tanto en la parte impl\u00edcita como en la parte expl\u00edcita del m\u00e9todo.</p> <p>A diferencia de un sistema lineal general, cuya soluci\u00f3n mediante m\u00e9todos cl\u00e1sicos como la eliminaci\u00f3n gaussiana requiere un costo computacional de orden \\(O(N^3)\\), los sistemas tridiagonales pueden resolverse en tiempo lineal, es decir, \\(O(N)\\), utilizando el m\u00e9todo de Thomas. Este m\u00e9todo es una versi\u00f3n especializada de la eliminaci\u00f3n de Gauss que aprovecha la estructura tridiagonal para reducir el n\u00famero de operaciones necesarias. El m\u00e9todo transforma la matriz original en una matriz triangular superior mediante una etapa de eliminaci\u00f3n hacia adelante, y luego obtiene la soluci\u00f3n aplicando sustituci\u00f3n hacia atr\u00e1s.</p> <p>Al trabajar con solo tres vectores (diagonal principal, inferior y superior), se evita almacenar la matriz completa reduciendo el consumo de memoria.</p>"},{"location":"python/","title":"Solui\u00f3n en Python","text":"<p>En el presente apartado explicaremos a detalle cada linea de codigo de la resolucion de la Ecuacion de calor realizada en Python.</p> <p>El codigo tiene 3 diferentes condiciones inciales y 3 diferentes condiciones de frontera, por lo que para obtener los 3 graficos esperados, debemos de escoger una opcion para cada condicion inicial y de frontera. </p> <p>Iniciamos importando las librerias, en donde numpy nos ayuda a realizar calculos numericos y el manejo de arreglos/matirces; matplotlib.pyplot, grafica y visualiza datos;  scipy.sparse.diags, permite crear matrices dispersas que ahorran memoria y son mas eficientes; scipy.sparse.linalg.spsolve, resuelve sistemas lineales que usan matrices dispersas; FuncAnimation, permite crear animaciones y Image, sirve para mostrar imagenes en entornos como Jupyter Notebook. </p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.sparse import diags\nfrom scipy.sparse.linalg import spsolve\nfrom matplotlib.animation import FuncAnimation\nfrom IPython.display import Image\n</code></pre> <p>Par\u00e1metros; alpha es la constante de difusi\u00f3n t\u00e9rmica, controla que tan rapido se difunde el calor. </p> <pre><code>alpha = 1.0\n</code></pre> <p>Configuraci\u00f3n del dominio; se define un dominio cuadrado [0,1] x [0,1], se divide ese dominio en 20 segmentos en cada direccion, dx y dy corresponde al tamano de cada celda, es decir, el espaciado entre nodos. </p> <pre><code>Longitud_x, Longitud_y = 1.0, 1.0  # Estos son los largos del dominio en x e y respectivamente \nnum_divisiones_x, num_divisiones_y = 20, 20  # Cantidad de divisiones en las direcciones x e y\n\n#Tama\u00f1o de cada celda (Resoluci\u00f3n espacial)\ndx, dy = Longitud_x / num_divisiones_x, Longitud_y / num_divisiones_y  # Distancia entre nodos consecutivos en cada eje\n</code></pre> <p>Malla de coordenadas; el np.linspace(...) genera nodos equiespaciados entre 0 y 1, X, Y son las matrices que representan la malla completa del dominio, las cuales son utiles para graficar. </p> <pre><code>x = np.linspace(0, Longitud_x, num_divisiones_x+1)  # Puntos equiespaciados de 0 a Lx (incluyendo extremos)\ny = np.linspace(0, Longitud_y, num_divisiones_y+1)  # Puntos equiespaciados de 0 a Ly (incluyendo extremos)\nX, Y = np.meshgrid(x, y, indexing='ij')\n</code></pre> <p>Configuraci\u00f3n temporal</p> <pre><code>T = 0.2      # Tiempo total de simulaci\u00f3n\ndt = 0.001   # Paso temporal\nnt = int(T / dt)  # N\u00famero total de pasos de tiempo\n</code></pre> <p>C\u00e1lculo de par\u00e1metros auxiliares para Crank-Nicolson en x en y; se divide entre 2 para la estabilidad y precision (Crank-Nicolson), estos parametros se usan para construir las matrices tridiagonales. </p> <pre><code>parametro_x = alpha * dt / (2 * dx**2)  # Par\u00e1metro de difusi\u00f3n en x, dividido entre 2 por Crank-Nicolson\nparametro_y = alpha * dt / (2 * dy**2)  # Igual pero en y\n</code></pre> <p>Construcci\u00f3n de matrices tridiagonales para el m\u00e9todo impl\u00edcito en x</p> <pre><code>Ax = diags([[-parametro_x]*(num_divisiones_x-1), [1+2*parametro_x]*(num_divisiones_x-1), [-parametro_x]*(num_divisiones_x-1)], [-1,0,1], shape=(num_divisiones_x-1, num_divisiones_x-1))  # Matriz del lado izquierdo (impl\u00edcito) en x\nBx = diags([[parametro_x]*(num_divisiones_x-1), [1-2*parametro_x]*(num_divisiones_x-1), [parametro_x]*(num_divisiones_x-1)], [-1,0,1], shape=(num_divisiones_x-1, num_divisiones_x-1))    # Matriz del lado derecho (expl\u00edcito) en x\n</code></pre> <p>Construcci\u00f3n de matrices tridiagonales para el m\u00e9todo impl\u00edcito en y</p> <pre><code>Ay = diags([[-parametro_y]*(num_divisiones_y-1), [1+2*parametro_y]*(num_divisiones_y-1), [-parametro_y]*(num_divisiones_y-1)], [-1,0,1], shape=(num_divisiones_y-1, num_divisiones_y-1))  # Impl\u00edcito en y\nBy = diags([[parametro_y]*(num_divisiones_y-1), [1-2*parametro_y]*(num_divisiones_y-1), [parametro_y]*(num_divisiones_y-1)], [-1,0,1], shape=(num_divisiones_y-1, num_divisiones_y-1))    # Expl\u00edcito en y\n</code></pre> <p>Condici\u00f3n Inicial; se inicializa toda la matriz u con ceros y luego la llena con una onda senoidal doble.</p> <pre><code>u = np.zeros((num_divisiones_x+1, num_divisiones_y+1))  # Inicializaci\u00f3n de la matriz de temperatura u en todo el dominio\n</code></pre> <p>Ahora, vienen las 3 opciones de condiciones inciales, las cuales son Pulso Gaussiano centrado, Paraboloide centrado y Onda senosoidal.</p> <p>Opci\u00f3n 1: Pulso gaussiano centrado en (0.5, 0.5). Se crea un pulso de calor concentrado en el centro del dominio, X y Y son las coordenadas de cada punto en la malla, el factor 100 controla que tan centrado esta el calor. </p> <pre><code>u[:, :] = np.exp(-100 * ((X - 0.5)**2 + (Y - 0.5)**2))\n</code></pre> <p>Opci\u00f3n 2: Paraboloide centrado (Alternativa f\u00edsicamente consistente). Esta centrado en (0.5, 0.5) y tiene su valor minimo en el centro. </p> <pre><code>u[:, :] = 10 * ((X - 0.5)**2 + (Y - 0.5)**2)\n</code></pre> <p>Opci\u00f3n 3: Onda senosoidal suave (Para patrones peri\u00f3dicos), se usa una onda senoidal en ambas direcciones y y y, el 2 pi garantiza que la onda tiene un ciclo completo entre 0 y 1. </p> <pre><code>u[:, :] = np.sin(2 * np.pi * X) * np.sin(2 * np.pi * Y)\n</code></pre> <p>Matriz para almacenar la pr\u00f3xima temperatura</p> <pre><code>u_proxima = np.zeros_like(u) # Matriz que contendr\u00e1 la temperatura actualizada\n</code></pre> <p>Simulacion</p> <p>Inicializacion, esta es la lista para guardar estados intermedios.</p> <pre><code>historial_temperaturas = []\nintervalo_guardado = 10 # Guarda cada 10 pasos de tiempo\n</code></pre> <p>Bucle de tiempo, comienza el lazo de integraci\u00f3n temporal; el for n in range(nt) itera desde t=0 hasta t=T</p> <pre><code>for n in range(nt):\n</code></pre> <p>Paso intermedio: resolvemos en la direcci\u00f3n x, manteniendo y fijo. Es decir, fijamos una fila j y resolvemos en x, se forma el lado derecho con Bx y se resuelve el sistema lineal con Ax. </p> <pre><code>    u_intermedia = np.zeros_like(u)  # Matriz temporal para almacenar resultados intermedios\n    # Recorremos cada fila fija (j) y resolvemos en x (columnas)\n    for j in range(1, num_divisiones_y):\n        rhs = Bx.dot(u[1:num_divisiones_x, j])              # Lado derecho del sistema: combinaci\u00f3n expl\u00edcita\n        u_intermedia[1:num_divisiones_x, j] = spsolve(Ax, rhs)    # Resolvemos el sistema lineal en x\n</code></pre> <p>Paso final: resolvemos en la direcci\u00f3n y, manteniendo x fijo. </p> <pre><code>    for i in range(1, num_divisiones_x):\n        rhs = By.dot(u_intermedia[i, 1:num_divisiones_y])  # Lado derecho para direcci\u00f3n y\n        u_proxima[i, 1:num_divisiones_y] = spsolve(Ay, rhs)   # Soluci\u00f3n del sistema lineal en y\n</code></pre> <p>Aplicar la Condici\u00f3n de Frontera seleccionada a u_proxima. Nuevamente, vienen 3 diferentes opciones de condiciones de frontera, Dirichlet, Neumann y Robin. </p> <p>Opci\u00f3n 1: Dirichlet (bordes fijos en 0); se fija la temperatura en los bordes a un valor constante y representa un material en contacto con un medio frio constante. </p> <pre><code>    u_proxima[0, :] = 0; u_proxima[-1, :] = 0; u_proxima[:, 0] = 0; u_proxima[:, -1] = 0\n</code></pre> <p>Opci\u00f3n 2: Neumann (flujo de calor nulo en los bordes); la derivada normal de la temperatura es 0, no hay flujo a traves del borde, es decir, no entra ni sale calor por los bordes. </p> <pre><code>    u_proxima[0, :] = u_proxima[1, :]\n    u_proxima[-1, :] = u_proxima[-2, :]\n    u_proxima[:, 0] = u_proxima[:, 1]\n    u_proxima[:, -1] = u_proxima[:, -2]\n</code></pre> <p>Opci\u00f3n 3: Robin (convecci\u00f3n en los bordes); es un caso intermedio entre Dirichlet y Neumann, representa la transferencia de calor por conveccion entre el sistema y un medio exterior.</p> <pre><code>    beta = 3.0 # Se puede modificar el valor  (Coeficiente de transferencia de calor en fronteras [W/m\u00b2K])\n    u_proxima[0, :] = u_proxima[1, :] / (1 + beta * dx)\n    u_proxima[-1, :] = u_proxima[-2, :] / (1 + beta * dx)\n    u_proxima[:, 0] = u_proxima[:, 1] / (1 + beta * dy)\n    u_proxima[:, -1] = u_proxima[:, -2] / (1 + beta * dy)\n</code></pre> <p>Actualizamos la soluci\u00f3n completa para el siguiente paso de tiempo; se actualiza u para el siguiente paso y se guarda el estado si corresponde. </p> <pre><code>    u[:, :] = u_proxima[:, :]  # Se copia el resultado actualizado de u_proxima a u\n\n    # Guardar estado actual periodicamente\n    if n % intervalo_guardado == 0:\n        historial_temperaturas.append(u.copy())\n</code></pre> <p>Visualizaci\u00f3n; muestra la primera distribucion de temperatura en un grafico de contornos de color. </p> <pre><code>print(f\"Total de estados guardados: {len(historial_temperaturas)}\")\n\nfig, ax = plt.subplots(figsize=(7, 6))\nmapa_calor = ax.contourf(X, Y, historial_temperaturas[0], 20, cmap='hot')\ncbar = fig.colorbar(mapa_calor, ax=ax) \nax.set_title(f\"Crank-Nicolson ADI 2D (t={0:.3f} s)\")\nax.set_xlabel(\"x\")\nax.set_ylabel(\"y\")\n</code></pre> <p>Funci\u00f3n para actualizar la animaci\u00f3n; pdate(frame) es la funcion que actualiza el grafico en cada paso y FuncAnimation crea la animacion completa de la evolucion temporal. </p> <pre><code>def update(frame):\n    ax.clear() # Limpiar el gr\u00e1fico anterior\n    mapa_calor = ax.contourf(X, Y, historial_temperaturas[frame], 20, cmap='hot') # Crear nuevo mapa de calor\n    ax.set_title(f\"t = {frame * intervalo_guardado * dt:.3f} s\")\n    ax.set_xlabel(\"x\")\n    ax.set_ylabel(\"y\")\n\nanim = FuncAnimation(fig, update, frames=len(historial_temperaturas), interval=400, blit=False) # 400ms entre frames\nplt.close(fig) # Cerrar la figura est\u00e1tica\n</code></pre> <p>Guardar animacion; guarda la animacion en formato .mp4 </p> <pre><code>mp4_filename = \"difusion_calor_Onda-Robin.mp4\"\n\nprint(f\"Saving animation to {mp4_filename}...\")\ntry:\n    anim.save(mp4_filename, writer=\"ffmpeg\", fps=10)\n    print(\"Animation saved successfully.\")\nexcept Exception as e:\n    print(f\"Error saving animation: {e}\")\n</code></pre> <p>Mapa de calor 2D del resultado final, es decir, la visualizacion final de la distribucion de temperatura en t = T. </p> <pre><code>plt.figure(figsize=(7, 6))\ncp_final = plt.contourf(X, Y, u, 20, cmap='hot')\nplt.colorbar(cp_final)\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"resultados/","title":"An\u00e1lisis de resultados","text":""},{"location":"resultados/#python","title":"Python","text":""},{"location":"resultados/#grafico-y-simulacion-del-pulso-gaussiano-con-condicion-de-frontera-de-dirichlet","title":"Grafico y simulacion del pulso Gaussiano con condicion de frontera de Dirichlet.","text":"<p>En base a lo observado la solucion de dichos graficos es simetrica, lo cual se espera por la simetria del pulso y la geometria cuadrada. La temperaturadecrece hacia los bordes, puesto que al tener la condicion inicial de Dirichlet, la temperatura es fija en cero. Hay presencia de contornos concentricos desde el centro hacia afuera, indicando asi una difusion isotropica, es decir, una difusion igual en todas las direcciones.  El comportamiento del grafico y la simulacion es correcto, puesto que la difusion se comporta como predice la ecuacion de calor, es decir, que se presenta una distribucion de temperatura uniforme, no hay oscilaciones artificiales ni errores numericos y se cumplen las condiciones de frontera establecidas. </p>"},{"location":"resultados/#grafico-y-simulacion-de-un-paraboloide-centrado-con-condicion-de-frontera-de-neumann","title":"Grafico y simulacion de un paraboloide centrado con condicion de frontera de Neumann.","text":"<p>Al tener dichas condiciones iniciales y de frontera, las mismas hacen que se refleje el calor, lo que provoca que no se pierda energia termica por las fronteras. Se observa una acumulacion de calor en las esquinas, lo que es caracteristico cuando se inicia con un minimo central y se impide que el calor escape. Ademas, el gradiente de temperatura apunta hacia el centro, lo cual es consistente cuando se presenta un paraboloide negativo.  Por lo que los resultados de este grafico y simulacion son los esperados, ya que se observa que no hay perdida de calor por los bordes, que la condicion de Neumann esta bien aplicada y que respeta las simetrias y propiedades del metodo utilizado. </p>"},{"location":"resultados/#grafico-y-simulacion-de-una-onda-senosoidal-con-condicion-de-frontera-de-robin","title":"Grafico y simulacion de una onda senosoidal con condicion de frontera de Robin.","text":"<p>Se logra observar que el patron senoidal se conserva, lo que sugiere una posible solucion estacionaria o un estado inicial muy cercano al equilibrio. EL grafico y la simulacion muestra dos maximos positivos y dos minimos negativos, lo que es correcto cuando se trabaja con una onda con 2 ciclos en cada eje. Los valores son muy pequeno, lo que indica que el sistema esta cerrado cerca del equilibrio termico o con condiciones suaves. La condicion de frontera de Robin, permite un intercambio parcial de calor en los bordes, lo que es coherente con la conservacion parcial del perfil de onda, ademas, en soluciones senoidales estacionarias es comun ver un patron simetrico y balanceado positivo-negativo, lo cual, se logra apreciar en el grafico y la simulacion. </p>"}]}